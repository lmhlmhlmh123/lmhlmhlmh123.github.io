<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React中使用柯里化函数提交表单</title>
    <url>/2023/05/18/currytizationFunction/</url>
    <content><![CDATA[<h2 id="高阶函数-函数柯里化"><a href="#高阶函数-函数柯里化" class="headerlink" title="高阶函数_函数柯里化"></a>高阶函数_函数柯里化</h2><p>如果一个函数符合下面2个规范中的任何一个 那么该函数就是高阶函数<br>    1、若A函数 接收参数是一个函数 那么A就可以称之为高阶函数<br>    2、若A函数 调用的返回值依然是一个函数 那么A就可以称之为高阶函数<br>    常见的高阶函数有：Promise setTimeout arr.map()等等</p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a><strong>函数柯里化</strong></h3><p>通过函数调用继续返回函数的方式 实现多次接收参数最后统一处理函数编码的形式</p>
<ul>
<li><p>使用柯里化函数提交表单</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    saveFormData=<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[data]:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;(event)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">                event.preventDefault()</span></span><br><span class="line"><span class="language-xml">                alert(`用户名是$&#123;this.state.username&#125;,密码是$&#123;this.state.password&#125;`)</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">username</span>&#x27;)&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">password</span>&#x27;)&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>不使用函数柯里化提交表单</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">user</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    saveFormData=<span class="function">(<span class="params">dataType,event</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(event)</span>=&gt;</span>this.saveFormData(&#x27;username&#x27;,event)&#125; type=&#x27;text&#x27;/&gt;</span></span><br><span class="line"><span class="language-xml">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(event)</span>=&gt;</span>this.saveFormData(&#x27;password&#x27;,event)&#125; type=&#x27;passord&#x27;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中父传子、子传父、兄弟传值、多层级传递</title>
    <url>/2023/05/19/conduction/</url>
    <content><![CDATA[<h2 id="React中父传子、子传父、兄弟传值、多层级传递"><a href="#React中父传子、子传父、兄弟传值、多层级传递" class="headerlink" title="React中父传子、子传父、兄弟传值、多层级传递"></a>React中父传子、子传父、兄弟传值、多层级传递</h2><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><ul>
<li>【父组件】给【子组件】传递数据：通过props传递<h5 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span> <span class="attr">text</span>=<span class="string">&quot;hello React&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="Home-jsx"><a href="#Home-jsx" class="headerlink" title="Home.jsx"></a>Home.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* hello React */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4></li>
<li>【父组件】给【子组件】传递数据：通过props传递<h5 id="App-jsx-1"><a href="#App-jsx-1" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 父组件向子组件传递一个回调 父组件通过回调的方式接收子组件传递过来的数据 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span> <span class="attr">onFunction</span>=<span class="string">&#123;(data)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">        console.log(data) //&#123;name: &#x27;zs&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="Home-jsx-1"><a href="#Home-jsx-1" class="headerlink" title="Home.jsx"></a>Home.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [obj]=<span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 点击按钮 向父组件传递数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onBtn</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        props.<span class="title function_">onFunction</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onBtn&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="兄弟传值-消息订阅与发布机制"><a href="#兄弟传值-消息订阅与发布机制" class="headerlink" title="兄弟传值(消息订阅与发布机制)"></a>兄弟传值(消息订阅与发布机制)</h4><ul>
<li>【兄弟组件】给【兄弟组件】传递数据：通过pubsub-js传递<pre><code>  - 适用于任何组件间通信
  - 下载命令：npm i pubsub-js --save
  - 在需要发布订阅的组件中引入：import PubSub from &#39;pubsub-js&#39;
  - 发布的组件：PubSub.publish(&#39;aaa&#39;,传递的参数)
  - 订阅的组件：PubSub.subscribe(&#39;aaa&#39;,通过回调的方式接收)
</code></pre>
</li>
</ul>
<h5 id="YoungerBrother-jsx（传递数据的兄弟组件）"><a href="#YoungerBrother-jsx（传递数据的兄弟组件）" class="headerlink" title="YoungerBrother.jsx（传递数据的兄弟组件）"></a>YoungerBrother.jsx（传递数据的兄弟组件）</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PubSub</span> <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">YoungerBrother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [obj]=<span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 向兄弟传递数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onBtn</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;aaa&#x27;</span>,obj)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onBtn&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="ElderBrother-jsx（接收数据的兄弟组件）"><a href="#ElderBrother-jsx（接收数据的兄弟组件）" class="headerlink" title="ElderBrother.jsx（接收数据的兄弟组件）"></a>ElderBrother.jsx（接收数据的兄弟组件）</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PubSub</span> <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ElderBrother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 兄弟组件通过PubSub.subscribe接收</span></span><br><span class="line">    <span class="comment">// 回调函数有两个参数 第一个是字符串 第二个参数是传递过来的数据</span></span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="function">(<span class="params">string,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(string,data) <span class="comment">// aaa &#123;name: &#x27;zs&#x27;, age: 18&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ElderBrother<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h4 id="多层级传递-上下文数据共享"><a href="#多层级传递-上下文数据共享" class="headerlink" title="多层级传递(上下文数据共享)"></a>多层级传递(上下文数据共享)</h4><h5 id="Context-jsx"><a href="#Context-jsx" class="headerlink" title="Context.jsx"></a>Context.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 创建上下文的内置插件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 创建上下文</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> [data]=<span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;border:</span>&#x27;<span class="attr">1px</span> <span class="attr">solid</span> #<span class="attr">000</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是A组件也是父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户名是：&#123;data.name&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 通过上下文中的内置属性Provider 将data分发出去 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">B</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第一种接收方式 通过useContext接收</span></span><br><span class="line">    <span class="keyword">const</span> data=<span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;border:</span>&#x27;<span class="attr">1px</span> <span class="attr">solid</span> <span class="attr">red</span>&#x27;,<span class="attr">marginTop:</span>&#x27;<span class="attr">20px</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是B组件也是A组件子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>从父级接收到用户名是：&#123;data.name&#125;，年龄：&#123;data.age&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">C</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 后代组件可以通过useContext接收 参数是创建的上下文</span></span><br><span class="line">    <span class="keyword">const</span> data=<span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;border:</span>&#x27;<span class="attr">1px</span> <span class="attr">solid</span> <span class="attr">blue</span>&#x27;,<span class="attr">marginTop:</span>&#x27;<span class="attr">20px</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是C组件也是A组件孙子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>从爷级接收到用户名是：&#123;data.name&#125;，年龄：&#123;data.age&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">D</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">D</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;border:</span>&#x27;<span class="attr">1px</span> <span class="attr">solid</span> <span class="attr">yellow</span>&#x27;,<span class="attr">marginTop:</span>&#x27;<span class="attr">20px</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是D组件也是A组件重孙组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/* // 第二种接收方式 通过上下文中的内置属性Consumer接收 */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;</span></span><br><span class="line"><span class="language-xml">                        value=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">h3</span>&gt;</span>从太爷级接收到用户名是：&#123;value.name&#125;，年龄：&#123;value.age&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊搜索</title>
    <url>/2023/05/19/dimSearch/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Cinema</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [data, setData] = <span class="title function_">useState</span>([])</span><br><span class="line">  <span class="keyword">let</span> [text, setText] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="comment">// 请求数据</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;https://m.maizuo.com/gateway?cityId=110100&amp;ticketFlag=1&amp;k=420101&quot;</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;X-Client-Info&quot;</span>: <span class="string">&#x27;&#123;&quot;a&quot;:&quot;3000&quot;,&quot;ch&quot;:&quot;1002&quot;,&quot;v&quot;:&quot;5.2.1&quot;,&quot;e&quot;:&quot;16842878395119008311345153&quot;,&quot;bc&quot;:&quot;110100&quot;&#125;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;X-Host&#x27;</span>: <span class="string">&#x27;mall.film-ticket.cinema.list&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setData</span>(res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">cinemas</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">// 将搜索写成函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getCinemaList</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">          <span class="comment">// 返回遍历的数据</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//模糊搜索    将数据的字符串和输入的字符串都转为大写 提高匹配几率</span></span><br><span class="line">          <span class="keyword">return</span> item.<span class="property">address</span>.<span class="title function_">toUpperCase</span>().<span class="title function_">includes</span>(text.<span class="title function_">toUpperCase</span>()) || item.<span class="property">name</span>.<span class="title function_">toUpperCase</span>().<span class="title function_">includes</span>(text.<span class="title function_">toUpperCase</span>())</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;cinemaBox&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 受控组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">className</span>=<span class="string">&#x27;input&#x27;</span> <span class="attr">value</span>=<span class="string">&#123;text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">        setText(e.target.value)</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          // 通过搜索函数渲染</span></span><br><span class="line"><span class="language-xml">          getCinemaList().map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;cinemaList&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;item.cinemaId&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">dt</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">dt</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">14px</span>&#x27;, <span class="attr">color:</span> &quot;#<span class="attr">ccc</span>&quot; &#125;&#125;&gt;</span>&#123;item.address&#125;<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>列表优化</title>
    <url>/2023/05/19/listoptimize/</url>
    <content><![CDATA[<h2 id="长列表优化"><a href="#长列表优化" class="headerlink" title="长列表优化"></a>长列表优化</h2><h5 id="第一种做法（使用定时器分批分堆渲染）"><a href="#第一种做法（使用定时器分批分堆渲染）" class="headerlink" title="第一种做法（使用定时器分批分堆渲染）"></a>第一种做法（使用定时器分批分堆渲染）</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 第一种做法 分批分堆渲染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [list, setList] = <span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">averageFn</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">//从第0个开始截取</span></span><br><span class="line">            <span class="keyword">let</span> result = [] <span class="comment">//定义结果 结果是二维数组</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; list.<span class="property">length</span>) &#123; <span class="comment">//当i等于或者大于总长度时，即截取完毕</span></span><br><span class="line">                <span class="comment">// 从原始数组的第一项开始遍历</span></span><br><span class="line">                result.<span class="title function_">push</span>(list.<span class="title function_">slice</span>(i, i + <span class="number">10</span>)) <span class="comment">//在原有一万条数据上，一次截取10个用于分堆</span></span><br><span class="line">                i = i + <span class="number">10</span> <span class="comment">// 这10条数据截取完，再截取下十条数据，以此类推</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result <span class="comment">//最后把结果丢出去即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">Fn</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">            <span class="keyword">let</span> res=<span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/index&#x27;</span>)</span><br><span class="line">            <span class="keyword">let</span> towDArr=<span class="title function_">averageFn</span>(res.<span class="property">data</span>.<span class="property">data</span>) <span class="comment">//调用截取函数 将请求的数据传给它</span></span><br><span class="line">            <span class="keyword">let</span> arr=[]</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;towDArr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 相当于在很短的时间内创建许多个定时任务去处理</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    arr.<span class="title function_">push</span>(...towDArr[i])</span><br><span class="line">                    <span class="title function_">setList</span>([...arr]) <span class="comment">// 赋值渲染</span></span><br><span class="line">                &#125;,<span class="number">2000</span>*i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Fn</span>()</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">margin:</span> <span class="attr">30</span> &#125;&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span>ID:&#123;item.id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span>NAME:&#123;item.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span>VALAUE:&#123;item.value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中配置代理</title>
    <url>/2023/05/19/proxy/</url>
    <content><![CDATA[<h2 id="配置跨域代理"><a href="#配置跨域代理" class="headerlink" title="配置跨域代理"></a>配置跨域代理</h2><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><ul>
<li>在package.json中追加配置 “proxy”:”<a href="http://localhost:5000&quot;">http://localhost:5000&quot;</a><br>说明:<pre><code>  - 优点：配置简单 前端请求资源时可以不加任何前缀
  - 缺点：不能配置多个代理
  - 工作方式：上述方式配置代理 当请求了3000不存在的资源时 那么该请求会转发给5000(优先匹配前端资源)
</code></pre>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;proxy&quot;</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="需要发起请求的页面"><a href="#需要发起请求的页面" class="headerlink" title="需要发起请求的页面"></a>需要发起请求的页面</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getStudentData</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/text/index&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;getStudentData&#125;</span>&gt;</span>点我获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><ul>
<li>在src目录下创建代理配置文件setupProxy.js<br>说明：<pre><code>  - 优点：可以配置多个代理 可以灵活的控制请求是否走代理
  - 缺点：配置繁琐 前端请求资源必须加前缀
</code></pre>
<h5 id="编写配置文件setupProxy-js"><a href="#编写配置文件setupProxy-js" class="headerlink" title="编写配置文件setupProxy.js"></a>编写配置文件setupProxy.js</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要采用CommonJS的写法</span></span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(</span><br><span class="line">        <span class="title function_">createProxyMiddleware</span>(<span class="string">&#x27;/api-elm&#x27;</span>, <span class="comment">//遇见/api-elm前缀的请求,就会触发该代理配置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//请求转发给谁（能返回数据的服务器地址）</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,  <span class="comment">//控制服务器收到的响应头中Host字段的值</span></span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api-elm&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125; <span class="comment">//重写请求路径，保证交给后台服务器是正常地请求地址（必须配置）</span></span><br><span class="line">        &#125;),</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="需要发起请求的页面-1"><a href="#需要发起请求的页面-1" class="headerlink" title="需要发起请求的页面"></a>需要发起请求的页面</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getStudentData</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;/api-elm/text/index&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;getStudentData&#125;</span>&gt;</span>点我获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux中间件RTK的使用（持久化版）</title>
    <url>/2023/05/19/redux/</url>
    <content><![CDATA[<h2 id="同步RTK（持久化）"><a href="#同步RTK（持久化）" class="headerlink" title="同步RTK（持久化）"></a>同步RTK（持久化）</h2><h5 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span>  &#123;store&#125;  <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="comment">// 分发状态</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">Home</span>  <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h5><ul>
<li>在src目录下创建store.js文件<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入创建store的工具</span></span><br><span class="line"><span class="keyword">import</span> &#123;configureStore&#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="comment">// 引入持久化的工具 //下载方法npm i redux-persist</span></span><br><span class="line"><span class="keyword">import</span> &#123;persistStore,persistReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-persist&#x27;</span></span><br><span class="line"><span class="comment">// 引入存储方法</span></span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">&#x27;redux-persist/lib/storage&#x27;</span></span><br><span class="line"><span class="comment">// 引入切片</span></span><br><span class="line"><span class="keyword">import</span> counterSlice  <span class="keyword">from</span> <span class="string">&quot;./slice&quot;</span></span><br><span class="line"><span class="comment">// 持久化</span></span><br><span class="line"><span class="keyword">const</span> persistConfig = &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    storage,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将切片存入persistReducer</span></span><br><span class="line"><span class="keyword">const</span> persistedReducer = <span class="title function_">persistReducer</span>(persistConfig,counterSlice);</span><br><span class="line"><span class="comment">// 将持久化的切片导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: persistedReducer,</span><br><span class="line">    <span class="attr">middleware</span>: <span class="function">(<span class="params">getDefaultMiddleware</span>) =&gt;</span></span><br><span class="line">    <span class="title function_">getDefaultMiddleware</span>(&#123;</span><br><span class="line">        <span class="attr">serializableCheck</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> persistor = <span class="title function_">persistStore</span>(store)</span><br></pre></td></tr></table></figure></div>
<h5 id="slice-js"><a href="#slice-js" class="headerlink" title="slice.js"></a>slice.js</h5></li>
<li>在src目录下创建slice.js文件<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createSlice&#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice=<span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="attr">reducers</span>:&#123;</span><br><span class="line">        <span class="attr">jia</span>:<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">value</span>+=<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">jian</span>:<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">value</span>-=<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">jiaAction</span>:<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">value</span>+=action.<span class="property">payload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123;jia,jian,jiaAction&#125; =counterSlice.<span class="property">actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Home-jsx"><a href="#Home-jsx" class="headerlink" title="Home.jsx"></a>Home.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// 引入connect用于连接UI组件与redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;jia,jian,jiaAction&#125; <span class="keyword">from</span> <span class="string">&quot;../redux/slice&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// const counter=useSelector((state)=&gt;state.value)</span></span><br><span class="line">    <span class="comment">// const dispatch=useDispatch()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(counter)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>props.jia()&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>props.jian()&#125;&gt;-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>props.jiaAction(5)&#125;&gt;+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">    <span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">value</span>:state.<span class="property">vlaue</span>&#125;),</span><br><span class="line">    <span class="function"><span class="params">dispatch</span>=&gt;</span>(&#123;</span><br><span class="line">        <span class="attr">jia</span>:<span class="function">()=&gt;</span>&#123;<span class="title function_">dispatch</span>(<span class="title function_">jia</span>())&#125;,</span><br><span class="line">        <span class="attr">jian</span>:<span class="function">()=&gt;</span>&#123;<span class="title function_">dispatch</span>(<span class="title function_">jian</span>())&#125;,</span><br><span class="line">        <span class="attr">jiaAction</span>:<span class="function">(<span class="params">number</span>)=&gt;</span>&#123;<span class="title function_">dispatch</span>(<span class="title function_">jiaAction</span>(number))&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">)(<span class="title class_">Home</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="异步RTK（持久化）"><a href="#异步RTK（持久化）" class="headerlink" title="异步RTK（持久化）"></a>异步RTK（持久化）</h2><h5 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span>  &#123;store&#125;  <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="App-jsx-1"><a href="#App-jsx-1" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">Home</span>  <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="store-js-1"><a href="#store-js-1" class="headerlink" title="store.js"></a>store.js</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入创建store的工具</span></span><br><span class="line"><span class="keyword">import</span> &#123;configureStore&#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="comment">// 引入持久化的工具 //下载方法npm i redux-persist</span></span><br><span class="line"><span class="keyword">import</span> &#123;persistStore,persistReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-persist&#x27;</span></span><br><span class="line"><span class="comment">// 引入存储方法</span></span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">&#x27;redux-persist/lib/storage&#x27;</span></span><br><span class="line"><span class="comment">// 引入切片</span></span><br><span class="line"><span class="keyword">import</span> counterSlice  <span class="keyword">from</span> <span class="string">&quot;./slice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 持久化</span></span><br><span class="line"><span class="keyword">const</span> persistConfig = &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    storage,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将切片存入persistReducer</span></span><br><span class="line"><span class="keyword">const</span> persistedReducer = <span class="title function_">persistReducer</span>(persistConfig,counterSlice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: persistedReducer,</span><br><span class="line">    <span class="attr">middleware</span>: <span class="function">(<span class="params">getDefaultMiddleware</span>) =&gt;</span></span><br><span class="line">    <span class="title function_">getDefaultMiddleware</span>(&#123;</span><br><span class="line">        <span class="attr">serializableCheck</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> persistor = <span class="title function_">persistStore</span>(store)</span><br></pre></td></tr></table></figure></div>
<h5 id="slice-js-1"><a href="#slice-js-1" class="headerlink" title="slice.js"></a>slice.js</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入创建切片的工具 以及创建异步的工具</span></span><br><span class="line"><span class="keyword">import</span> &#123;createSlice,createAsyncThunk&#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="comment">// 引入网络请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 通过createAsyncThunk发送网络请求 第一个参数是声明 第二个参数是回调</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchHomeMultidataAction =<span class="title function_">createAsyncThunk</span>(</span><br><span class="line">    <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">    <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> res=<span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8888/goods/list&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    <span class="attr">data</span>:[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice=<span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="comment">// 使用extraReducers解析异步路由 extraReducers有三个状态 fulfilled成功 padding进行中 reject失败</span></span><br><span class="line">    <span class="attr">extraReducers</span>:&#123;</span><br><span class="line">        [fetchHomeMultidataAction.<span class="property">fulfilled</span>](state,&#123;payload&#125;)&#123;</span><br><span class="line">            <span class="comment">// 请求成功后将数据放到初始化的data数组中</span></span><br><span class="line">            state.<span class="property">data</span>=payload.<span class="property">list</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 导出切片</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure></div>
<h5 id="Home-jsx-1"><a href="#Home-jsx-1" class="headerlink" title="Home.jsx"></a>Home.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 引入connect用于连接UI组件与redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// import &#123; useDispatch, useSelector &#125; from &#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;fetchHomeMultidataAction&#125; <span class="keyword">from</span> <span class="string">&quot;../redux/slice&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// const counter=useSelector((state)=&gt;state.data)</span></span><br><span class="line">    <span class="comment">// const dispatch=useDispatch()</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">data</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        props.<span class="title function_">qingqiu</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并暴露Home的容器组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">    <span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">data</span>:state.<span class="property">data</span>&#125;),</span><br><span class="line">    <span class="function"><span class="params">dispatch</span>=&gt;</span>(&#123;</span><br><span class="line">        <span class="attr">qingqiu</span>:<span class="function">()=&gt;</span>&#123;<span class="title function_">dispatch</span>(<span class="title function_">fetchHomeMultidataAction</span>())&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">)(<span class="title class_">Home</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fetch发送请求(关注分离的设计思想)</title>
    <url>/2023/05/19/request/</url>
    <content><![CDATA[<h2 id="使用fetch发送请求"><a href="#使用fetch发送请求" class="headerlink" title="使用fetch发送请求"></a>使用fetch发送请求</h2><ul>
<li>特点：<br>  无需下载 直接引用即可<br>  fetch：原生函数 不再使用XMLHttpRequest对象提交ajax请求<br>  老版本的浏览器不支持<br>  语法简洁，更加语义化<br>  基于标准 Promise 实现，支持 async/await<br>  同构方便，使用 <a class="link"   href="https://github.com/matthew-andrews/isomorphic-fetch" >isomorphic-fetch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>  更加底层，提供的API丰富（request, response）<br>  脱离了XHR，是ES规范里新的实现方式<br>  fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>  fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>  fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>  fetch没有办法原生监测请求的进度，而XHR可以<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span>=<span class="keyword">async</span>(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="comment">// 发送网络请求----- 通过Fetch(优化)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//先帮你联系服务器 然后返回Promise实例</span></span><br><span class="line">      <span class="keyword">const</span> response= <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`http://localhost:5000/text/index`</span>) </span><br><span class="line">      <span class="comment">// 之后通过实例上的.json()获取数据</span></span><br><span class="line">      <span class="keyword">const</span> data= <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">      <span class="comment">// 打印数据</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错了&#x27;</span>,error)</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">func</span>()</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      111</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React富文本展示</title>
    <url>/2023/05/19/richText/</url>
    <content><![CDATA[<h2 id="富文本展示"><a href="#富文本展示" class="headerlink" title="富文本展示"></a>富文本展示</h2><ul>
<li>假如有一天后端人员善心大发给我们返回了一段html代码片段，我们该如何渲染呢<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [data,setData]=<span class="title function_">useState</span>(<span class="string">&quot;&lt;div&gt;111&lt;h1&gt;222&lt;/h1&gt;&lt;/div&gt;&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:data&#125;&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React路由的使用</title>
    <url>/2023/05/19/router/</url>
    <content><![CDATA[<h2 id="React路由的理解"><a href="#React路由的理解" class="headerlink" title="React路由的理解"></a>React路由的理解</h2><ul>
<li><p>1、什么是路由<br>  ① 一个路由就是一个映射关系(key:value)<br>  ② key为路径 value可能是function或component</p>
</li>
<li><p>2、路由分类<br>  一、后端路由</p>
<pre><code>  ① 理解：value是function 用来处理客户端提交的请求
  ② 注册路由：router.get(path，function(req,res))
  ③ 工作过程：当node接收一个请求时 根据请求路径找到匹配的路由 调用路由中的函数来处理请求 返回响应数据
</code></pre>
<p>  二、前端路由</p>
<pre><code>  ① 浏览器端路由：value是element 用于展示页面内容
  ② 注册路由 &lt;Route path=&#39;/test&#39; element=&#123;Test&#125;&gt;
  ③ 工作过程：当浏览器的path变为/test时 当前路由组件就会变为Test组件
</code></pre>
</li>
</ul>
<h2 id="React路由的原理"><a href="#React路由的原理" class="headerlink" title="React路由的原理"></a>React路由的原理</h2><ul>
<li>1、let history=History.createBrowserHistory() //方法一 直接使用H5推出的history身上的API</li>
<li>2、let history=History.createHashHistory() 方法二 hash值(锚点)</li>
</ul>
<h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><h5 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Route</span>,<span class="title class_">Routes</span>,<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./components/About&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.css&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 在React中靠路由链接实现切换组件 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><h5 id="App-jsx-1"><a href="#App-jsx-1" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Route</span>,<span class="title class_">Routes</span>,<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./components/About&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.css&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 在React中靠路由链接实现切换组件 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            &#123;/* 重定向需要使用Navigate */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;about&#x27;</span> /&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="路由高亮"><a href="#路由高亮" class="headerlink" title="路由高亮"></a>路由高亮</h2><h5 id="App-jsx-2"><a href="#App-jsx-2" class="headerlink" title="App.jsx"></a>App.jsx</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Route</span>,<span class="title class_">Routes</span>,<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./components/About&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.css&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 在React中靠路由链接实现切换组件 */&#125;</span></span><br><span class="line"><span class="language-xml">          &#123;/* NavLink中自定义active的名字需要通过回调的形式来书写 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&#123;(&#123;isActive&#125;)</span>=&gt;</span>isActive?&#x27;list-group-item abcdefg&#x27;:&#x27;list-group-item&#x27;&#125; to=&#x27;/about&#x27;&gt;About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&#123;(&#123;isActive&#125;)</span>=&gt;</span>isActive?&#x27;list-group-item abcdefg&#x27;:&#x27;list-group-item&#x27;&#125;&gt;Home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            &#123;/* 重定向需要使用Navigate */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;about&#x27;</span> /&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><h5 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h5><ul>
<li>在src目录下新建一个router.js文件 用于存放路由<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/News&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Message</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Message&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Detail&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>,</span><br><span class="line">        <span class="comment">// 二级路由</span></span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">News</span>/&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Message</span>/&gt;</span></span>,</span><br><span class="line">                <span class="comment">// 三级路由</span></span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span>/&gt;</span></span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 路由重定向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<h5 id="App-jsx-3"><a href="#App-jsx-3" class="headerlink" title="App.jsx"></a>App.jsx</h5></li>
<li>在App.jsx页面挂载路由表<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>,useRoutes&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.css&#x27;</span></span><br><span class="line"><span class="comment">// 引入路由表</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过useRoutes挂载路由表</span></span><br><span class="line">  <span class="keyword">const</span> element=<span class="title function_">useRoutes</span>(routes)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 在React中靠路由链接实现切换组件 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 挂载路由表 */&#125;</span></span><br><span class="line"><span class="language-xml">              &#123;element&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div>
<h5 id="Home-jsx"><a href="#Home-jsx" class="headerlink" title="Home.jsx"></a>Home.jsx</h5></li>
<li>在二级路由需要展示页面 留下一个路由坑<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>,<span class="title class_">Outlet</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是Home页面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&#123;(&#123;isActive&#125;)</span>=&gt;</span>isActive?&#x27;list-group-item abcdefg&#x27;:&#x27;list-group-item&#x27;&#125; to=&#x27;/home/news&#x27;&gt;News<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&#123;(&#123;isActive&#125;)</span>=&gt;</span>isActive?&#x27;list-group-item abcdefg&#x27;:&#x27;list-group-item&#x27;&#125; to=&#x27;/home/message&#x27;&gt;Message<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 指定路由组件呈现的位置 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="路由三种传参方式"><a href="#路由三种传参方式" class="headerlink" title="路由三种传参方式"></a>路由三种传参方式</h2><h3 id="第一种Params"><a href="#第一种Params" class="headerlink" title="第一种Params"></a>第一种Params</h3><h5 id="Message-jsx"><a href="#Message-jsx" class="headerlink" title="Message.jsx"></a>Message.jsx</h5></li>
<li>在Message.jsx页面 通过/拼接的方式传递数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Outlet</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">let</span> [message]=<span class="title function_">useState</span>([</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息1&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;11111&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;2&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息2&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;22222&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;3&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息3&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;33333&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;4&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息4&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;44444&#x27;</span>&#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    message.map((item)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                        return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;/* 第一种传参方式 params */&#125;</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`<span class="attr">detail</span>/$&#123;<span class="attr">item.id</span>&#125;/$&#123;<span class="attr">item.title</span>&#125;/$&#123;<span class="attr">item.content</span>&#125;`&#125;&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 指定路由的展示链接 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="router-js-1"><a href="#router-js-1" class="headerlink" title="router.js"></a>router.js</h5></li>
<li>在router.js文件中 将detail的路径拼接上参数<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/News&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Message</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Message&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Detail&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">News</span>/&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Message</span>/&gt;</span></span>,</span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 第一种传参方式</span></span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>,</span><br><span class="line">                        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span>/&gt;</span></span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<h5 id="Detail-jsx"><a href="#Detail-jsx" class="headerlink" title="Detail.jsx"></a>Detail.jsx</h5></li>
<li>在Detail.jsx页面 通过useParams()接收数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第一种传参方式 params 通过useParams接收</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id,title,content&#125;=<span class="title function_">useParams</span>()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Detail<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="第二种Search"><a href="#第二种Search" class="headerlink" title="第二种Search"></a>第二种Search</h3><h5 id="Message-jsx-1"><a href="#Message-jsx-1" class="headerlink" title="Message.jsx"></a>Message.jsx</h5></li>
<li>在Message.jsx页面 通过?拼接的方式传递数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Outlet</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">let</span> [message]=<span class="title function_">useState</span>([</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息1&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;11111&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;2&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息2&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;22222&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;3&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息3&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;33333&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;4&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息4&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;44444&#x27;</span>&#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    message.map((item)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                        return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;/* 第二种传参方式 params */&#125;</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`<span class="attr">detail</span>?<span class="attr">id</span>=<span class="string">$&#123;item.id&#125;&amp;title</span>=<span class="string">$&#123;item.title&#125;&amp;content</span>=<span class="string">$&#123;item.content&#125;</span>`&#125;&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 指定路由的展示链接 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="router-js-2"><a href="#router-js-2" class="headerlink" title="router.js"></a>router.js</h5></li>
<li>在router.js文件中 detail的路径不需要更改<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/News&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Message</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Message&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Detail&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">News</span>/&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Message</span>/&gt;</span></span>,</span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 第二种传参方式</span></span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span>/&gt;</span></span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<h5 id="Detail-jsx-1"><a href="#Detail-jsx-1" class="headerlink" title="Detail.jsx"></a>Detail.jsx</h5></li>
<li>在Detail.jsx页面 通过useSearchParams()接收数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSearchParams&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 第二种传参方式 search 通过useSearchParams接收 通过.get接收你传入的某一个参数</span></span><br><span class="line">        <span class="keyword">let</span> [data,setData]=<span class="title function_">useSearchParams</span>()</span><br><span class="line">        <span class="keyword">const</span> id=data.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> title=data.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> content=data.<span class="title function_">get</span>(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Detail<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="第三种State"><a href="#第三种State" class="headerlink" title="第三种State"></a>第三种State</h3><h5 id="Message-jsx-2"><a href="#Message-jsx-2" class="headerlink" title="Message.jsx"></a>Message.jsx</h5></li>
<li>在Message.jsx页面 通过state方式传递数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Link</span>,<span class="title class_">Outlet</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">let</span> [message]=<span class="title function_">useState</span>([</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息1&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;11111&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;2&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息2&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;22222&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;3&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息3&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;33333&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;4&#x27;</span>,<span class="attr">title</span>:<span class="string">&quot;消息4&quot;</span>,<span class="attr">content</span>:<span class="string">&#x27;44444&#x27;</span>&#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    message.map((item)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                        return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;/* 第三种传参方式 */&#125;</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;detail&#x27;</span> <span class="attr">state</span>=<span class="string">&#123;&#123;id:item.id,title:item.title,content:item.content&#125;&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 指定路由的展示链接 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="router-js-3"><a href="#router-js-3" class="headerlink" title="router.js"></a>router.js</h5></li>
<li>在router.js文件中 detail的路径不需要更改<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/News&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Message</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Message&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/HomeChildren/Detail&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">News</span>/&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Message</span>/&gt;</span></span>,</span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 第三种传参方式</span></span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span>/&gt;</span></span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<h5 id="Detail-jsx-2"><a href="#Detail-jsx-2" class="headerlink" title="Detail.jsx"></a>Detail.jsx</h5></li>
<li>在Detail.jsx页面 通过useLocation()接收数据<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/* 第三种传参方式 state 通道useLocation获取 */</span></span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">state</span>:&#123;id,title,content&#125;&#125;=<span class="title function_">useLocation</span>()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Detail<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="React路由懒加载"><a href="#React路由懒加载" class="headerlink" title="React路由懒加载"></a>React路由懒加载</h2><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123;lazy,<span class="title class_">Suspense</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>, <span class="title class_">Route</span>,<span class="title class_">Routes</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">// 懒加载的组件需要使用lazy使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span>=<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Home&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span>=<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/About&#x27;</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 和懒加载配合的组件 需要传入一个回调 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span>Loading.....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>/&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span>/&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>; </span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>封装一个上传图片的组件</title>
    <url>/2023/05/19/upload/</url>
    <content><![CDATA[<h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><h4 id="后台配置"><a href="#后台配置" class="headerlink" title="后台配置"></a>后台配置</h4><h5 id="upLoad-js"><a href="#upLoad-js" class="headerlink" title="upLoad.js"></a>upLoad.js</h5><ul>
<li>在后台controller文件夹下创建一个upLoad.js文件<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;mz/fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">&#x27;mkdirp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Controller</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Controller</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lmhUpload</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> &#123;</span><br><span class="line">    <span class="comment">// 调用这个方法</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">updatepuSubPic</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="comment">// 需要前往 config/config.default.js 设置 config.multipart 的 mode 属性为 file</span></span><br><span class="line">        <span class="keyword">const</span> file = ctx.<span class="property">request</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 声明存放资源的路径</span></span><br><span class="line">        <span class="keyword">let</span> pusubPics = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// let id = &#x27;&#x27;;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ctx.request.files[0] 表示获取第一个文件，若前端上传多个文件则可以遍历这个数组对象</span></span><br><span class="line">            <span class="keyword">const</span> f = fs.<span class="title function_">readFileSync</span>(file.<span class="property">filepath</span>);</span><br><span class="line">            <span class="comment">// 1.获取当前日期</span></span><br><span class="line">            <span class="keyword">const</span> day = <span class="title function_">moment</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line">            <span class="comment">// 2.创建图片保存的路径</span></span><br><span class="line">            <span class="comment">// 需要前往 config/config.default.js 设置 config.pusubPics 路径为app/public/pusubPics</span></span><br><span class="line">            <span class="keyword">const</span> dir = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">pusubPics</span>, day);</span><br><span class="line">            <span class="keyword">const</span> date = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 毫秒数</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">mkdirp</span>(dir); <span class="comment">// 不存在就创建目录</span></span><br><span class="line">            <span class="comment">// 返回图片保存的路径</span></span><br><span class="line">            pusubPics = path.<span class="title function_">join</span>(dir, date + path.<span class="title function_">extname</span>(file.<span class="property">filename</span>));</span><br><span class="line">            <span class="comment">// decodeURI是为了中文乱码</span></span><br><span class="line">            <span class="comment">// id = await ctx.service.dlqupload.add(&#123; img_url: api + uploadDir, filename: decodeURI(file.filename) &#125;);</span></span><br><span class="line">            <span class="comment">// 写入文件夹</span></span><br><span class="line">            fs.<span class="title function_">writeFileSync</span>(pusubPics, f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, e);</span><br><span class="line">            <span class="comment">// 清除临时文件</span></span><br><span class="line">            ctx.<span class="title function_">cleanupRequestFiles</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;上传成功&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: pusubPics.<span class="title function_">replace</span>(<span class="regexp">/app/g</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="comment">// id,</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = lmhUpload;</span><br></pre></td></tr></table></figure></div>
<h5 id="config-default-js"><a href="#config-default-js" class="headerlink" title="config.default.js"></a>config.default.js</h5></li>
<li>在后台config文件夹下的config.default.js中添加配置<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Egg.EggAppInfo</span>&#125; appInfo app info</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">appInfo</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * built-in config</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type</span> &#123;<span class="type">Egg.EggAppConfig</span>&#125;</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">const</span> config = (<span class="built_in">exports</span> = &#123;&#125;);</span><br><span class="line">  <span class="comment">// 图片上传</span></span><br><span class="line">  config.<span class="property">uploadDir</span> = <span class="string">&#x27;app/public/upload&#x27;</span>;</span><br><span class="line">  <span class="comment">// add your middleware config here</span></span><br><span class="line">  config.<span class="property">middleware</span> = [];</span><br><span class="line">  config.<span class="property">uploadDir</span> = <span class="string">&#x27;app/public/upload&#x27;</span>;</span><br><span class="line">  <span class="comment">// use for cookie sign key, should change to your own and keep security</span></span><br><span class="line">  config.<span class="property">keys</span> = appInfo.<span class="property">name</span> + <span class="string">&#x27;_1639723070889_7073&#x27;</span>;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">mysql</span> = &#123;</span><br><span class="line">    <span class="comment">// 单数据库信息配置</span></span><br><span class="line">    <span class="attr">client</span>: &#123;</span><br><span class="line">      <span class="comment">// host</span></span><br><span class="line">      <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">      <span class="comment">// 端口号</span></span><br><span class="line">      <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">      <span class="comment">// 用户名</span></span><br><span class="line">      <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="comment">// 密码</span></span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">      <span class="comment">// 数据库名</span></span><br><span class="line">      <span class="attr">database</span>: <span class="string">&#x27;egou&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">    <span class="attr">app</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">    <span class="attr">agent</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">security</span> = &#123;</span><br><span class="line">    <span class="comment">// 关闭 csrf</span></span><br><span class="line">    <span class="attr">csrf</span>: &#123;</span><br><span class="line">      <span class="attr">enable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 跨域白名单</span></span><br><span class="line">    <span class="attr">domainWhiteList</span>: [ <span class="string">&#x27;*&#x27;</span> ],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许跨域的方法</span></span><br><span class="line">  config.<span class="property">cors</span> = &#123;</span><br><span class="line">    <span class="attr">origin</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="attr">allowMethods</span>: <span class="string">&#x27;GET, PUT, POST, DELETE, PATCH&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">uploadDir</span> = <span class="string">&#x27;app/public/upload&#x27;</span>;</span><br><span class="line">  config.<span class="property">pusubPics</span> = <span class="string">&#x27;app/public/pusubPics&#x27;</span>;</span><br><span class="line">  <span class="comment">// add your middleware config here</span></span><br><span class="line">  config.<span class="property">middleware</span> = [];</span><br><span class="line">  <span class="comment">// add your user config here</span></span><br><span class="line">  <span class="keyword">const</span> userConfig = &#123;</span><br><span class="line">    <span class="comment">// myAppName: &#x27;egg&#x27;,</span></span><br><span class="line">  &#125;;</span><br><span class="line">  config.<span class="property">multipart</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">    <span class="attr">fileSize</span>: <span class="string">&#x27;1048576000&#x27;</span>,</span><br><span class="line">    <span class="attr">whitelist</span>: [ <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span> ],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    ...userConfig,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h5></li>
<li>在后台路由管理文件中添加路由<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, controller.<span class="property">lmhUpload</span>.<span class="property">updatepuSubPic</span>);</span><br></pre></td></tr></table></figure></div>
<h5 id="http-js"><a href="#http-js" class="headerlink" title="http.js"></a>http.js</h5></li>
<li>在前端请求文件中添加请求<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">postUpload</span>(<span class="params">url, fileList</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> param = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">    param.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileList.<span class="property">raw</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">post</span>(<span class="string">`http://127.0.0.1:7001<span class="subst">$&#123;url&#125;</span>`</span>, param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="UpLoad-jsx"><a href="#UpLoad-jsx" class="headerlink" title="UpLoad.jsx"></a>UpLoad.jsx</h5></li>
<li>封装一个图片上传的组件 该组件使用的UI库是tdesign-mobile-react<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Upload</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;tdesign-mobile-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;tdesign-mobile-react/es/style/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;postUpload&#125; <span class="keyword">from</span> <span class="string">&quot;../app/https&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UpLoad</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [fileList,setFileList]=<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="keyword">const</span> files=[]</span><br><span class="line">    <span class="keyword">let</span> [arr,setArr]=<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        fileList.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">postUpload</span>(<span class="string">&#x27;/upload&#x27;</span>,item).<span class="title function_">then</span>(<span class="title function_">async</span>(res)=&gt;&#123;</span><br><span class="line">                <span class="keyword">const</span> obj=res.<span class="property">data</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;\\\\&#x27;</span>,<span class="string">&#x27;\\/&#x27;</span>)</span><br><span class="line">                <span class="keyword">const</span> http=<span class="string">&quot;http://127.0.0.1:7001&quot;</span>+obj</span><br><span class="line">                <span class="title function_">setArr</span>([...arr,http])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;,[fileList])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        props.<span class="title function_">getImage</span>(arr)</span><br><span class="line">    &#125;,[arr])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Upload</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">multiple</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">autoUpload</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">defaultFiles</span>=<span class="string">&#123;files&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1:7001/pubilc&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">beforeUpload</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">                &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                onChange=&#123;(e)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                    setFileList(e)</span></span><br><span class="line"><span class="language-xml">                &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="Topic-jsx"><a href="#Topic-jsx" class="headerlink" title="Topic.jsx"></a>Topic.jsx</h5></li>
<li>在需要上传图片的组件中引入Upload组件<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&quot;./topic.module.css&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UpLoad</span> <span class="keyword">from</span> <span class="string">&#x27;../../../../components/UpLoad&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Topic</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [obj,setObj]=<span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">images</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 副作用</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断obj中的数据是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="property">images</span>!==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// useEffect根据obj.text的变化执行</span></span><br><span class="line">    &#125;,[obj.<span class="property">images</span>])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.box&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 上传图片 */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;/* 向子组件传给回调 子组件调用并传参 父组件接收参数 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">UpLoad</span> <span class="attr">getImage</span>=<span class="string">&#123;(http)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            const arr=http.map((item)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                return item.replaceAll(&#x27;\\&#x27;,&#x27;/&#x27;)</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">            // 将接到的参数转为字符串 存入obj.images中</span></span><br><span class="line"><span class="language-xml">            setObj(&#123;...obj,images:JSON.stringify(arr)&#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目的性能优化</title>
    <url>/2023/05/09/optimization/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是作者通过实际项目的优化实践进行总结而来，希望读者读完本文，有一定的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成：</p>
<p>Vue 代码层面的优化；</p>
<p>webpack 配置层面的优化；</p>
<p>基础的 Web 技术层面的优化。</p>
<h2 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h2><h3 id="1-v-if-和-v-show-区分使用场景"><a href="#1-v-if-和-v-show-区分使用场景" class="headerlink" title="1. v-if 和 v-show 区分使用场景"></a>1. <strong>v-if 和 v-show 区分使用场景</strong></h3><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="2-computed-和-watch-区分使用场景"><a href="#2-computed-和-watch-区分使用场景" class="headerlink" title="2. computed 和 watch 区分使用场景"></a>2. <strong>computed 和 watch 区分使用场景</strong></h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>运用场景：</p>
<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h3 id="3-v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#3-v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="3. v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>3. <strong>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</strong></h3><p>（1）v-for 遍历必须为 item 添加 key</p>
<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>
<p>（2）v-for 遍历避免同时使用 v-if</p>
<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>
<p>推荐：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;user in activeUsers&quot;</span><br><span class="line">    :key=&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: function () &#123;</span><br><span class="line">    return this.users.filter(function (user) &#123;</span><br><span class="line">   return user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>不推荐：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;user in users&quot;</span><br><span class="line">    v-if=&quot;user.isActive&quot;</span><br><span class="line">    :key=&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-长列表性能优化"><a href="#4-长列表性能优化" class="headerlink" title="4. 长列表性能优化"></a>4. <strong>长列表性能优化</strong></h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: () =&gt; (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  async created() &#123;</span><br><span class="line">    const users = await axios.get(&quot;/api/users&quot;);</span><br><span class="line">    this.users = Object.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-事件的销毁"><a href="#5-事件的销毁" class="headerlink" title="5. 事件的销毁"></a>5. <strong>事件的销毁</strong></h3><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="6-图片资源懒加载"><a href="#6-图片资源懒加载" class="headerlink" title="6. 图片资源懒加载"></a>6. <strong>图片资源懒加载</strong></h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>（1）安装插件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（2）在入口文件 man.js 中引入并使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueLazyload from &#x27;vue-lazyload&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后再 vue 中直接使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>或者添加自定义选项</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: 1.3,</span><br><span class="line">error: &#x27;dist/error.png&#x27;,</span><br><span class="line">loading: &#x27;dist/loading.gif&#x27;,</span><br><span class="line">attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。</p>
<h3 id="7-路由懒加载"><a href="#7-路由懒加载" class="headerlink" title="7. 路由懒加载"></a>7. <strong>路由懒加载</strong></h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p>路由懒加载：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Foo = () =&gt; import(&#x27;./Foo.vue&#x27;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;/foo&#x27;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-第三方插件的按需引入"><a href="#8-第三方插件的按需引入" class="headerlink" title="8. 第三方插件的按需引入"></a>8. <strong>第三方插件的按需引入</strong></h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p>
<p>（1）首先，安装 babel-plugin-component ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（2）然后，将 .babelrc 修改为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（3）在 main.js 中引入部分组件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(Select)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-优化无限列表性能"><a href="#9-优化无限列表性能" class="headerlink" title="9. 优化无限列表性能"></a>9. <strong>优化无限列表性能</strong></h3><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。</p>
<h3 id="10-服务端渲染-SSR-or-预渲染"><a href="#10-服务端渲染-SSR-or-预渲染" class="headerlink" title="10. 服务端渲染 SSR or 预渲染"></a>10. <strong>服务端渲染 SSR or 预渲染</strong></h3><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p>（1）服务端渲染的优点：</p>
<p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
<p>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p>
<p>（2）服务端渲染的缺点：</p>
<p>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p>
<p>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
<p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</p>
<h2 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h2><h3 id="1-Webpack-对图片进行压缩"><a href="#1-Webpack-对图片进行压缩" class="headerlink" title="1. Webpack 对图片进行压缩"></a>1. <strong>Webpack 对图片进行压缩</strong></h3><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：</p>
<p>（1）首先，安装 image-webpack-loader ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000,</span><br><span class="line">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-减少-ES6-转为-ES5-的冗余代码"><a href="#2-减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="2. 减少 ES6 转为 ES5 的冗余代码"></a>2. <strong>减少 ES6 转为 ES5 的冗余代码</strong></h3><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HelloWebpack extends Component&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">babel-runtime/helpers/createClass  // 用于实现 class 语法</span><br><span class="line">babel-runtime/helpers/inherits  // 用于实现 extends 语法</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>
<p>（1）首先，安装 babel-plugin-transform-runtime ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>（2）然后，修改 .babelrc 配置文件为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。</p>
<h3 id="3-提取公共代码"><a href="#3-提取公共代码" class="headerlink" title="3. 提取公共代码"></a>3. <strong>提取公共代码</strong></h3><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<p>相同的资源被重复加载，浪费用户的流量和服务器的成本。</p>
<p>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</p>
<p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#x27;vendor&#x27;,</span><br><span class="line">  minChunks: function(module, count) &#123;</span><br><span class="line">    return (</span><br><span class="line">      module.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">      module.resource.indexOf(</span><br><span class="line">        path.join(__dirname, &#x27;../node_modules&#x27;)</span><br><span class="line">      ) === 0</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">// 抽取出代码模块的映射关系</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#x27;manifest&#x27;,</span><br><span class="line">  chunks: [&#x27;vendor&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。</p>
<h3 id="4-模板预编译"><a href="#4-模板预编译" class="headerlink" title="4. 模板预编译"></a>4. <strong>模板预编译</strong></h3><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>
<p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>
<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<h3 id="5-提取组件的-CSS"><a href="#5-提取组件的-CSS" class="headerlink" title="5. 提取组件的 CSS"></a>5. <strong>提取组件的 CSS</strong></h3><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>
<p>查阅这个构建工具各自的文档来了解更多：</p>
<p>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)</p>
<p>Browserify + vueify</p>
<p>Rollup + rollup-plugin-vue</p>
<h3 id="6-优化-SourceMap"><a href="#6-优化-SourceMap" class="headerlink" title="6. 优化 SourceMap"></a>6. <strong>优化 SourceMap</strong></h3><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p>
<p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p>
<p>开发环境推荐：cheap-module-eval-source-map</p>
<p>生产环境推荐：cheap-module-source-map</p>
<p>原因如下：</p>
<p>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p>
<p>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p>
<p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</p>
<p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p>
<h3 id="7-构建结果输出分析"><a href="#7-构建结果输出分析" class="headerlink" title="7. 构建结果输出分析"></a>7. <strong>构建结果输出分析</strong></h3><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。</p>
<p>我们在项目中 webpack.prod.conf.js 进行配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  var BundleAnalyzerPlugin =   require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>执行 $ npm run build –report 后生成分析报告如下：</p>
<h3 id="8-Vue-项目的编译优化"><a href="#8-Vue-项目的编译优化" class="headerlink" title="8. Vue 项目的编译优化"></a>8. <strong>Vue 项目的编译优化</strong></h3><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。</p>
<h2 id="三、基础的-Web-技术优化"><a href="#三、基础的-Web-技术优化" class="headerlink" title="三、基础的 Web 技术优化"></a>三、基础的 Web 技术优化</h2><h3 id="1-开启-gzip-压缩"><a href="#1-开启-gzip-压缩" class="headerlink" title="1. 开启 gzip 压缩"></a>1. <strong>开启 gzip 压缩</strong></h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p>
<p>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p>
<p>安装：</p>
<p>npm install compression –save 添加代码逻辑：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var compression = require(&#x27;compression&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(compression())</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-浏览器缓存"><a href="#2-浏览器缓存" class="headerlink" title="2. 浏览器缓存"></a>2. <strong>浏览器缓存</strong></h3><p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存）。</p>
<h3 id="3-CDN-的使用"><a href="#3-CDN-的使用" class="headerlink" title="3. CDN 的使用"></a>3. <strong>CDN 的使用</strong></h3><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<h3 id="4-使用-Chrome-Performance-查找性能瓶颈"><a href="#4-使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="4. 使用 Chrome Performance 查找性能瓶颈"></a>4. <strong>使用 Chrome Performance 查找性能瓶颈</strong></h3><p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p>
<p>打开 Chrome 开发者工具，切换到 Performance 面板</p>
<p>点击 Record 开始录制</p>
<p>刷新页面或展开某个节点</p>
<p>点击 Stop 停止录制</p>
<h1 id="性能优化面试题"><a href="#性能优化面试题" class="headerlink" title="性能优化面试题"></a>性能优化面试题</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/xnyh/xnyh1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h2><h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
<p>典型的CDN系统由下面三个部分组成：</p>
<ul>
<li><strong>分发服务系统：</strong>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li>
<li><strong>负载均衡系统：</strong>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li>
<li><strong>运营管理系统：</strong>运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li>
</ul>
<h3 id="2-CDN的作用"><a href="#2-CDN的作用" class="headerlink" title="2. CDN的作用"></a>2. CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。</p>
<p>（1）在性能方面，引入CDN的作用在于：</p>
<ul>
<li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li>
<li>部分资源请求分配给了CDN，减少了服务器的负载</li>
</ul>
<p>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</p>
<ul>
<li>针对DDoS：通过监控分析异常流量，限制其请求频率</li>
<li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</li>
</ul>
<p>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</p>
<h3 id="3-CDN的原理"><a href="#3-CDN的原理" class="headerlink" title="3. CDN的原理"></a>3. CDN的原理</h3><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 <a class="link"   href="http://www.test.com/" >www.test.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的解析过程如下：</p>
<p>（1） 检查浏览器缓存</p>
<p>（2）检查操作系统缓存，常见的如hosts文件</p>
<p>（3）检查路由器缓存</p>
<p>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询</p>
<p>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</p>
<ul>
<li>根服务器返回顶级域名(TLD)服务器如 <code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回 <code>.com</code>的地址</li>
<li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回 <code>.test</code>的地址</li>
<li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回 <code>www.test.com</code>的地址</li>
<li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li>
</ul>
<p><strong>CDN的工作原理：</strong></p>
<p>（1）用户未使用CDN缓存资源的过程：</p>
<ol>
<li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li>
<li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li>
<li>服务器向浏览器返回响应数据</li>
</ol>
<p>（2）用户使用CDN缓存资源的过程：</p>
<ol>
<li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li>
<li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li>
<li>用户向CDN的全局负载均衡设备发起数据请求</li>
<li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li>
<li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li>
<li>全局负载均衡设备把服务器的IP地址返回给用户</li>
<li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li>
</ol>
<p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p>
<p>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p>
<h3 id="4-CDN的使用场景"><a href="#4-CDN的使用场景" class="headerlink" title="4. CDN的使用场景"></a>4. CDN的使用场景</h3><ul>
<li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li>
<li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li>
<li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li>
</ul>
<h2 id="二、懒加载"><a href="#二、懒加载" class="headerlink" title="二、懒加载"></a>二、懒加载</h2><h3 id="1-懒加载的概念"><a href="#1-懒加载的概念" class="headerlink" title="1. 懒加载的概念"></a>1. 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p>
<p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>
<h3 id="2-懒加载的特点"><a href="#2-懒加载的特点" class="headerlink" title="2. 懒加载的特点"></a>2. 懒加载的特点</h3><ul>
<li><strong>减少无用资源的加载：</strong>使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li>
<li>**提升用户体验: **如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li>
<li><strong>防止加载过多图片而影响其他资源文件的加载 ：</strong>会影响网站应用的正常使用。</li>
</ul>
<h3 id="3-懒加载的实现原理"><a href="#3-懒加载的实现原理" class="headerlink" title="3. 懒加载的实现原理"></a>3. 懒加载的实现原理</h3><p>图片的加载是由 <code>src</code>引起的，当对 <code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的 <code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将 <code>data-xxx</code>中图片的路径赋值给 <code>src</code>，这样就实现了图片的按需加载，即懒加载。</p>
<p>注意：<code>data-xxx</code> 中的 <code>xxx</code>可以自定义，这里我们使用 <code>data-src</code>来定义。</p>
<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>
<p>使用原生JavaScript实现懒加载：</p>
<p><strong>知识点：</strong></p>
<p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度 <code>document.documentElement.clientHeight</code></p>
<p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离</p>
<p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>
<p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p>
<p><strong>代码实现：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var imgs = document.querySelectorAll(&#x27;img&#x27;);</span><br><span class="line">function lozyLoad()&#123;</span><br><span class="line">        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">        var winHeight= window.innerHeight;</span><br><span class="line">        for(var i=0;i &lt; imgs.length;i++)&#123;</span><br><span class="line">            if(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;</span><br><span class="line">                imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  window.onscroll = lozyLoad();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-懒加载与预加载的区别"><a href="#4-懒加载与预加载的区别" class="headerlink" title="4. 懒加载与预加载的区别"></a>4. 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<ul>
<li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li>
<li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong>通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li>
</ul>
<h2 id="三、回流与重绘"><a href="#三、回流与重绘" class="headerlink" title="三、回流与重绘"></a>三、回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li>页面的首次渲染</li>
<li>浏览器的窗口大小发生变化</li>
<li>元素的内容发生变化</li>
<li>元素的尺寸或者位置发生变化</li>
<li>元素的字体大小发生变化</li>
<li>激活CSS伪类</li>
<li>查询某些属性或者调用某些方法</li>
<li>添加或者删除可见的DOM元素</li>
</ul>
<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p>
<ul>
<li>全局范围：从根节点开始，对整个渲染树进行重新布局</li>
<li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li>
</ul>
<h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li>color、background 相关属性：background-color、background-image 等</li>
<li>outline 相关属性：outline-color、outline-width 、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p>
<h3 id="2-如何避免回流与重绘？"><a href="#2-如何避免回流与重绘？" class="headerlink" title="2. 如何避免回流与重绘？"></a>2. 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p>
<ul>
<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>不要使用 <code>table</code>布局， 一个小的改动可能会使整个 <code>table</code>进行重新布局</li>
<li>使用CSS的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>避免频繁操作DOM，可以创建一个文档片段 <code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>将元素先设置 <code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-如何优化动画？"><a href="#3-如何优化动画？" class="headerlink" title="3. 如何优化动画？"></a>3. 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的 <code>position</code>属性设置为 <code>absolute</code>或者 <code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p>
<h3 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对 <code>documentFragment</code>的解释：</p>
<p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
<p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p>
<h2 id="四、节流与防抖"><a href="#四、节流与防抖" class="headerlink" title="四、节流与防抖"></a>四、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul>
<li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li>
<li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li>
</ul>
<p><strong>防抖函数的应用场景：</strong></p>
<ul>
<li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</li>
<li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li>
</ul>
<p><strong>节流函数的适⽤场景：</strong></p>
<ul>
<li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</li>
<li>缩放场景：监控浏览器resize</li>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
</ul>
<h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = [...arguments];</span><br><span class="line"></span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>函数节流的实现：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 时间戳版</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = [...arguments],</span><br><span class="line">      nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定时器版</span><br><span class="line">function throttle (fun, wait)&#123;</span><br><span class="line">  let timeout = null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let context = this</span><br><span class="line">    let args = [...arguments]</span><br><span class="line">    if(!timeout)&#123;</span><br><span class="line">      timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">        fun.apply(context, args)</span><br><span class="line">        timeout = null </span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h2><h3 id="1-如何对项目中的图片进行优化？"><a href="#1-如何对项目中的图片进行优化？" class="headerlink" title="1. 如何对项目中的图片进行优化？"></a>1. 如何对项目中的图片进行优化？</h3><ol>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>
<li>小图使用 base64 格式</li>
<li>将多个图标文件整合到一张图片中（雪碧图）</li>
<li>选择正确的图片格式：</li>
<li><ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</li>
</ol>
<h3 id="2-常见的图片格式及使用场景"><a href="#2-常见的图片格式及使用场景" class="headerlink" title="2. 常见的图片格式及使用场景"></a>2. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p>
<p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p>
<p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p>
<p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p>
<p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p>
<p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</p>
<p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p>
<ul>
<li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
<h2 id="六、Webpack优化"><a href="#六、Webpack优化" class="headerlink" title="六、Webpack优化"></a>六、Webpack优化</h2><h3 id="1-如何提⾼webpack的打包速度"><a href="#1-如何提⾼webpack的打包速度" class="headerlink" title="1. 如何提⾼webpack的打包速度?"></a>1. 如何提⾼webpack的打包速度?</h3><h4 id="（1）优化-Loader"><a href="#（1）优化-Loader" class="headerlink" title="（1）优化 Loader"></a>（1）优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。</p>
<p>首先我们<strong>优化 Loader 的文件搜索范围</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p>
<p>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">loader: &#x27;babel-loader?cacheDirectory=true&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（2）HappyPack"><a href="#（2）HappyPack" class="headerlink" title="（2）HappyPack"></a>（2）HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p>
<p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: &#x27;happypack/loader?id=happybabel&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: &#x27;happybabel&#x27;,</span><br><span class="line">    loaders: [&#x27;babel-loader?cacheDirectory&#x27;],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（3）DllPlugin"><a href="#（3）DllPlugin" class="headerlink" title="（3）DllPlugin"></a>（3）DllPlugin</h4><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 想统一打包的类库</span><br><span class="line">    vendor: [&#x27;react&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    filename: &#x27;[name].dll.js&#x27;,</span><br><span class="line">    library: &#x27;[name]-[hash]&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      // name 必须和 output.library 一致</span><br><span class="line">      name: &#x27;[name]-[hash]&#x27;,</span><br><span class="line">      // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.join(__dirname, &#x27;dist&#x27;, &#x27;[name]-manifest.json&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(&#x27;./dist/vendor-manifest.json&#x27;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（4）代码压缩"><a href="#（4）代码压缩" class="headerlink" title="（4）代码压缩"></a>（4）代码压缩</h4><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p>
<p>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p>
<h4 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h4><p>可以通过一些小的优化点来加快打包速度</p>
<ul>
<li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li>
<li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li>
<li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li>
</ul>
<h3 id="2-如何减少-Webpack-打包体积"><a href="#2-如何减少-Webpack-打包体积" class="headerlink" title="2. 如何减少 Webpack 打包体积"></a>2. 如何减少 Webpack 打包体积</h3><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p>
<p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p>
<h4 id="（2）Scope-Hoisting"><a href="#（2）Scope-Hoisting" class="headerlink" title="（2）Scope Hoisting"></a>（2）Scope Hoisting</h4><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p>
<p>比如希望打包两个文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// test.js</span><br><span class="line">export const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于这种情况，打包出来的代码会类似这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（3）Tree-Shaking"><a href="#（3）Tree-Shaking" class="headerlink" title="（3）Tree Shaking"></a>（3）Tree Shaking</h4><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// test.js</span><br><span class="line">export const a = 1</span><br><span class="line">export const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p>
<p>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>
<h3 id="3-如何⽤webpack来优化前端性能？"><a href="#3-如何⽤webpack来优化前端性能？" class="headerlink" title="3. 如何⽤webpack来优化前端性能？"></a>3. 如何⽤webpack来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>
<ul>
<li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</li>
<li><strong>利⽤CDN加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</li>
<li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li>
<li><strong>Code Splitting</strong>: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li>
<li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h3 id="4-如何提⾼webpack的构建速度？"><a href="#4-如何提⾼webpack的构建速度？" class="headerlink" title="4. 如何提⾼webpack的构建速度？"></a>4. 如何提⾼webpack的构建速度？</h3><ol>
<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li>
<li>通过 externals 配置来提取常⽤库</li>
<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li>
<li>使⽤ Happypack 实现多线程加速编译</li>
<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li>
<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li>
</ol>
<h1 id="前端工程化面试题"><a href="#前端工程化面试题" class="headerlink" title="前端工程化面试题"></a>前端工程化面试题</h1><h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><h3 id="1-git-和-svn-的区别"><a href="#1-git-和-svn-的区别" class="headerlink" title="1. git 和 svn 的区别"></a>1. git 和 svn 的区别</h3><ul>
<li>git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码。</li>
<li>svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</li>
<li>svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</li>
<li>GIT把内容按元数据方式存储，而SVN是按文件：因为git目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</li>
<li>GIT分支和SVN的分支不同：svn会发生分支遗漏的情况，而git可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。</li>
<li>GIT没有一个全局的版本号，而SVN有</li>
<li>GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</li>
</ul>
<h3 id="2-经常使用的-git-命令？"><a href="#2-经常使用的-git-命令？" class="headerlink" title="2. 经常使用的 git 命令？"></a>2. 经常使用的 git 命令？</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                     // 新建 git 代码库</span><br><span class="line">git add                      // 添加指定文件到暂存区</span><br><span class="line">git rm                       // 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git commit -m [message]      // 提交暂存区到仓库区</span><br><span class="line">git branch                   // 列出所有分支</span><br><span class="line">git checkout -b [branch]     // 新建一个分支，并切换到该分支</span><br><span class="line">git status                   // 显示有变更文件的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-git-pull-和-git-fetch-的区别"><a href="#3-git-pull-和-git-fetch-的区别" class="headerlink" title="3. git pull 和 git fetch 的区别"></a>3. git pull 和 git fetch 的区别</h3><ul>
<li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li>
<li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li>
</ul>
<h3 id="4-git-rebase-和-git-merge-的区别"><a href="#4-git-rebase-和-git-merge-的区别" class="headerlink" title="4. git rebase 和 git merge 的区别"></a>4. git rebase 和 git merge 的区别</h3><p>git merge 和 git rebase 都是用于分支合并，关键<strong>在</strong> <strong>commit 记录的处理上不同</strong>：</p>
<ul>
<li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li>
<li>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</li>
</ul>
<h2 id="二、Webpack"><a href="#二、Webpack" class="headerlink" title="二、Webpack"></a>二、Webpack</h2><h3 id="1-webpack与grunt、gulp的不同？"><a href="#1-webpack与grunt、gulp的不同？" class="headerlink" title="1. webpack与grunt、gulp的不同？"></a>1. webpack与grunt、gulp的不同？</h3><p><strong>Grunt****、Gulp是基于任务运⾏的⼯具</strong>： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。</p>
<p><strong>Webpack是基于模块化打包的⼯具:</strong> ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。</p>
<p>因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npm script代替Grunt、Gulp，npm script同样可以打造任务流。</p>
<h3 id="2-webpack、rollup、parcel优劣？"><a href="#2-webpack、rollup、parcel优劣？" class="headerlink" title="2. webpack、rollup、parcel优劣？"></a>2. webpack、rollup、parcel优劣？</h3><ul>
<li>webpack适⽤于⼤型复杂的前端站点构建: webpack有强⼤的loader和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。</li>
<li>rollup适⽤于基础库的打包，如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。</li>
<li>parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。</li>
</ul>
<h3 id="3-有哪些常⻅的Loader？"><a href="#3-有哪些常⻅的Loader？" class="headerlink" title="3. 有哪些常⻅的Loader？"></a>3. 有哪些常⻅的Loader？</h3><ul>
<li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件</li>
<li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去</li>
<li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试</li>
<li>image-loader：加载并且压缩图⽚⽂件</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li>
<li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<p><strong>注意：在Webpack中，loader的执行顺序是从右向左</strong>执行的。因为webpack选择了<strong>compose这样的函数式编程方式</strong>，这种方式的表达式执行是从右向左的。</p>
<h3 id="4-有哪些常⻅的Plugin？"><a href="#4-有哪些常⻅的Plugin？" class="headerlink" title="4. 有哪些常⻅的Plugin？"></a>4. 有哪些常⻅的Plugin？</h3><ul>
<li>define-plugin：定义环境变量</li>
<li>html-webpack-plugin：简化html⽂件创建</li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li>
<li>webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度</li>
<li>webpack-bundle-analyzer: 可视化webpack输出⽂件的体积</li>
<li>mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载</li>
</ul>
<h3 id="5-bundle，chunk，module是什么？"><a href="#5-bundle，chunk，module是什么？" class="headerlink" title="5. bundle，chunk，module是什么？"></a>5. bundle，chunk，module是什么？</h3><ul>
<li>bundle：是由webpack打包出来的⽂件；</li>
<li>chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；</li>
<li>module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。</li>
</ul>
<h3 id="6-Loader和Plugin的不同？"><a href="#6-Loader和Plugin的不同？" class="headerlink" title="6. Loader和Plugin的不同？"></a>6. Loader和Plugin的不同？</h3><p>不同的作⽤:</p>
<ul>
<li>Loader直译为”加载器”。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。</li>
<li>Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>
</ul>
<p>不同的⽤法:</p>
<ul>
<li>Loader在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）</li>
<li>Plugin在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。</li>
</ul>
<h3 id="7-webpack的构建流程"><a href="#7-webpack的构建流程" class="headerlink" title="7. webpack的构建流程"></a>7. webpack的构建流程</h3><p>Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：</p>
<ol>
<li>初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
<li>开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译；</li>
<li>确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件；</li>
<li>编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；</li>
<li>完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
<li>输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</li>
</ol>
<p>在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。</p>
<h3 id="8-编写loader或plugin的思路？"><a href="#8-编写loader或plugin的思路？" class="headerlink" title="8. 编写loader或plugin的思路？"></a>8. 编写loader或plugin的思路？</h3><p>Loader像⼀个”翻译官”把读到的源⽂件内容转义成新的⽂件内容，并且每个Loader通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。</p>
<p>编写Loader时要遵循单⼀原则，每个Loader只做⼀种”转义”⼯作。 每个Loader的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给webpack。 还可以通过this.async() ⽣成⼀个 callback 函数，再⽤这个callback将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发loader的⼯具函数集——loader-utils 。</p>
<p>相对于Loader⽽⾔，Plugin的编写就灵活了许多。 webpack在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<h3 id="9-webpack的热更新是如何做到的？说明其原理？"><a href="#9-webpack的热更新是如何做到的？说明其原理？" class="headerlink" title="9. webpack的热更新是如何做到的？说明其原理？"></a>9. webpack的热更新是如何做到的？说明其原理？</h3><p>webpack的热更新⼜称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。</p>
<p>原理：</p>
<p>⾸先要知道server端和client端都做了处理⼯作：</p>
<ol>
<li>第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li>
<li>第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。</li>
<li>第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。</li>
<li>第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。</li>
<li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了webpack，webpack/hot/dev-server 的⼯作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。</li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li>
<li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。</li>
<li>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</li>
</ol>
<p>大概流程是我们用webpack-dev-server启动一个服务之后，浏览器和服务端是通过websocket进行长连接，webpack内部实现的watch就会监听文件修改，只要有修改就webpack会重新打包编译到内存中，然后webpack-dev-server依赖中间件webpack-dev-middleware和webpack之间进行交互，每次热更新都会请求一个携带hash值的json文件和一个js，websocker传递的也是hash值，内部机制通过hash值检查进行热更新， 至于内部原理，因为水平限制，目前还看不懂。</p>
<h3 id="10-如何⽤webpack来优化前端性能？"><a href="#10-如何⽤webpack来优化前端性能？" class="headerlink" title="10. 如何⽤webpack来优化前端性能？"></a>10. 如何⽤webpack来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>
<ul>
<li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</li>
<li><strong>利⽤CDN加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</li>
<li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li>
<li><strong>Code Splitting</strong>: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li>
<li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h3 id="11-如何提⾼webpack的打包速度"><a href="#11-如何提⾼webpack的打包速度" class="headerlink" title="11. 如何提⾼webpack的打包速度?"></a>11. 如何提⾼webpack的打包速度?</h3><ul>
<li>happypack: 利⽤进程并⾏编译loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类似的替代者是thread-loader</li>
<li>外部扩展(externals): 将不怎么需要更新的第三⽅库脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间，⽐如jQuery⽤script标签引⼊</li>
<li>dll: 采⽤webpack的 DllPlugin 和 DllReferencePlugin 引⼊dll，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间</li>
<li>利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼rebuild效率缩⼩⽂件搜索范围: ⽐如babel-loader插件,如果你的⽂件仅存在于src中,那么可以 include: path.resolve(__dirname,‘src’) ,当然绝⼤多数情况下这种操作的提升有限，除⾮不⼩⼼build了node_modules⽂件</li>
</ul>
<h3 id="12-如何提⾼webpack的构建速度？"><a href="#12-如何提⾼webpack的构建速度？" class="headerlink" title="12. 如何提⾼webpack的构建速度？"></a>12. 如何提⾼webpack的构建速度？</h3><ol>
<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li>
<li>通过 externals 配置来提取常⽤库</li>
<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li>
<li>使⽤ Happypack 实现多线程加速编译</li>
<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li>
<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li>
</ol>
<h3 id="13-怎么配置单⻚应⽤？怎么配置多⻚应⽤？"><a href="#13-怎么配置单⻚应⽤？怎么配置多⻚应⽤？" class="headerlink" title="13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？"></a>13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？</h3><p>单⻚应⽤可以理解为webpack的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤webpack的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是：</p>
<ul>
<li>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套css样式表</li>
<li>随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置</li>
</ul>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><h3 id="1-Babel的原理是什么"><a href="#1-Babel的原理是什么" class="headerlink" title="1. Babel的原理是什么?"></a>1. Babel的原理是什么?</h3><p>babel 的转译过程也分为三个阶段，这三步具体是：</p>
<ul>
<li><strong>解析 Parse</strong>: 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；</li>
<li><strong>转换 Transform</strong>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；</li>
<li><strong>⽣成 Generate</strong>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。</li>
</ul>
<h1 id="浏览器原理面试题"><a href="#浏览器原理面试题" class="headerlink" title="浏览器原理面试题"></a>浏览器原理面试题</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1. 什么是 XSS 攻击？"></a>1. 什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>获取页面的数据，如DOM、cookie、localStorage；</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>破坏页面结构；</li>
<li>流量劫持（将链接指向某网站）；</li>
</ul>
<h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>
<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</li>
<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>
</ul>
<p><strong>1）存储型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>
<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
<p><strong>2）反射型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>
<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>
<p><strong>3）DOM</strong> <strong>型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>⽤户打开带有恶意代码的 URL。</li>
<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>
<h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li><p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>
</li>
<li><p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>
<blockquote>
<ol>
<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ol>
</blockquote>
</li>
<li><p>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p>
</li>
</ul>
<h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>
<ul>
<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
<li><strong>对Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下:</p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获</li>
<li>服务器向客户端发送公钥</li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ul>
<h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题?"></a>6. 有哪些可能引起前端安全的问题?</h3><ul>
<li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</li>
<li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li>
<li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p>
<p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p>
<ul>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
<p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>
<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<p>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</p>
<p>（2）线程之间共享进程中的数据。</p>
<p>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，**当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p>（4）进程之间的内容相互隔离。**进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>
<p><strong>Chrome浏览器的架构图</strong>：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq2.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li>1 个浏览器主进程</li>
<li>1 个 GPU 进程</li>
<li>1 个网络进程</li>
<li>多个渲染进程</li>
<li>多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul>
<li>进程可以看做独立应用，线程不能</li>
<li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>
</ul>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq3.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><strong>（1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）事件触发线程</strong></p>
<p><strong>事件触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>
<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>
</ul>
<h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p>
<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p>管道的特点：</p>
<ul>
<li>只能单向通信</li>
<li>只能血缘关系的进程进行通信</li>
<li>依赖于文件系统</li>
<li>生命周期随进程</li>
<li>面向字节流的服务</li>
<li>管道内部提供了同步机制</li>
</ul>
<p><strong>（2）消息队列通信</strong></p>
<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<p><strong>（3）信号量通信</strong></p>
<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<p><strong>（4）信号通信</strong></p>
<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
<p><strong>（5）共享内存通信</strong></p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><strong>（6）套接字通信</strong></p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>
<li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li>
</ul>
<h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
<ul>
<li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>
<li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>
<li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>
<li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>
</ul>
<h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#x27;sw.js&#x27;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#x27;service worker 注册成功&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#x27;servcie worker 注册失败&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// sw.js</span><br><span class="line">// 监听 `install` 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#x27;install&#x27;, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#x27;my-cache&#x27;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#x27;./index.html&#x27;, &#x27;./index.js&#x27;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line">// 拦截所有请求事件</span><br><span class="line">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#x27;fetch source&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：</p>
<p>在 Cache 中也可以发现所需的文件已被缓存：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq4.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>
<ul>
<li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>
<li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>
<li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq5.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>
<ol>
<li><strong>Service Worker</strong>：<strong>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch </code>函数获取 数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li>
<li><strong>Memory Cache</strong>：Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>
<li><strong>Disk Cache</strong>：Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li>
</ol>
<p><strong>Disk Cache</strong>：Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：</p>
<ul>
<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p><code>Cache-Control</code>可设置的字段：</p>
<ul>
<li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；</li>
<li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
<li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>
<li><code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p><strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>
<li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>
</ul>
<h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p>上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li><code>max-age=xxx</code> 过期了</li>
<li>值为 <code>no-cache</code></li>
</ul>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <strong>Etag</strong> 和 <strong>Last-Modified</strong> 属性。</p>
<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>
<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>减少了服务器的负担，提高了网站的性能</li>
<li>加快了客户端网页的加载速度</li>
<li>减少了多余网络数据传输</li>
</ul>
<h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li>点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li>用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>
<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>
<ul>
<li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li>
<li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li>
</ul>
<h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>
<ul>
<li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li>
<li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li>
</ul>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul>
<li><strong>Trident</strong>：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li>
<li><strong>Gecko</strong>：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li>
<li><strong>Presto</strong>：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li>
<li><strong>Webkit</strong>：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li>
<li><strong>Blink</strong>：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li>
</ul>
<h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p>
<p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p>
<p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p>
<p>（4） Safari 浏览器内核：Webkit 内核；</p>
<p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p>
<p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p>
<p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p>
<p>（8） 百度浏览器、世界之窗内核：IE 内核；</p>
<p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p>
<p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p>
<h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul>
<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。</li>
<li><strong>浏览器引擎</strong> - 在⽤户界⾯和呈现引擎之间传送指令。</li>
<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li>**网络 **- ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。</li>
<li><strong>用户界面后端</strong> - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。</li>
<li><strong>JavaScript解释器</strong>。⽤于解析和执⾏ JavaScript 代码。</li>
<li><strong>数据存储</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>
<h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>大致过程如图所示：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq6.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><strong>注意</strong>：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript</strong>：JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<p>（1）尽量将JavaScript文件放在body的最后</p>
<p>（2） body中间尽量不要写 <code>&lt;script&gt;</code>标签</p>
<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
<ul>
<li>**script **立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li>
<li>**async **是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li>
<li>**defer **是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li>
</ul>
<p><strong>（2）针对CSS：使用CSS有三种方式：使用link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>
<li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>
<li><strong>style</strong>：GUI直接渲染</li>
</ul>
<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p><strong>（3）针对DOM树、CSSOM树：</strong></p>
<p>可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li>HTML文件的代码层级尽量不要太深</li>
<li>使用语义化的标签，来避免不标准语义化的特殊处理</li>
<li>减少CSSD代码的层级，因为选择器是从右向左进行解析的</li>
</ul>
<p><strong>（4）减少回流与重绘：</strong></p>
<ul>
<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>不要使用 <code>table</code>布局， 一个小的改动可能会使整个 <code>table</code>进行重新布局</li>
<li>使用CSS的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>避免频繁操作DOM，可以创建一个文档片段 <code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>将元素先设置 <code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<p>（1）关键资源的数量。</p>
<p>（2）关键路径长度。</p>
<p>（3）关键字节的数量。</p>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>
<p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>
<p>（3）优化关键字节数以缩短下载时间（往返次数）。</p>
<p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li>使用Nginx反向代理</li>
<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p><strong>Cookie的使用场景：</strong></p>
<ul>
<li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>
<li>可以用来统计页面的点击次数</li>
</ul>
<h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p><strong>LocalStorage的常用API：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 保存数据到 localStorage</span><br><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 获取数据</span><br><span class="line">let data = localStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除保存的数据</span><br><span class="line">localStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除所有保存的数据</span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">localStorage.key(index)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>LocalStorage的使用场景：</strong></p>
<ul>
<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
<h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage与LocalStorage对比：</strong></p>
<ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p><strong>SessionStorage的常用API：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 保存数据到 sessionStorage</span><br><span class="line">sessionStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 获取数据</span><br><span class="line">let data = sessionStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除保存的数据</span><br><span class="line">sessionStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除所有保存的数据</span><br><span class="line">sessionStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">sessionStorage.key(index)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>SessionStorage的使用场景</strong></p>
<ul>
<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
<h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>
<ul>
<li><strong>Name</strong>：cookie的名称</li>
<li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>
<li><strong>Size</strong>： cookie的大小</li>
<li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是 <code>/test</code>，那么只有 <code>/test</code>路径下的页面可以读取此cookie。</li>
<li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>
<li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>
<li><strong>HTTP</strong>： 该字段包含 <code>HTTPOnly </code>属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过 <code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>
<li><strong>Expires/Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>
</ul>
<p><strong>总结：</strong></p>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li><strong>cookie</strong>：其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>
<li><strong>sessionStorage</strong>：html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>
<li><strong>localStorage</strong>：html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>
</ul>
<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>
<li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>
<li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</li>
<li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</li>
<li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li>
</ul>
<h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>
<li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li>
<li><strong>同源限制</strong>：IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li>
<li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li>
<li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li>
</ul>
<h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>
<blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>
</blockquote>
<p>下表给出了与 URL <code>**http://store.company.com/dir/page.html**</code> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="http://store.company.com/dir/page.html" >http://store.company.com/dir/page.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>同源</td>
<td>完全相同</td>
</tr>
<tr>
<td><a class="link"   href="http://store.company.com/dir/inner/another.html" >http://store.company.com/dir/inner/another.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>同源</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><a class="link"   href="https://store.company.com/secure.html" >https://store.company.com/secure.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>跨域</td>
<td>协议不同</td>
</tr>
<tr>
<td><a class="link"   href="http://store.company.com:81/dir/etc.html" >http://store.company.com:81/dir/etc.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>跨域</td>
<td>端口不同 ( http:// 默认端口是80)</td>
</tr>
<tr>
<td><a class="link"   href="http://news.company.com/dir/other.html" >http://news.company.com/dir/other.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>跨域</td>
<td>主机不同</td>
</tr>
</tbody></table>
<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>
<p><strong>同源政策主要限制了三个方面：</strong></p>
<ul>
<li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>
<li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>
<li>当前域下 ajax 无法发送跨域请求。</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p>
<blockquote>
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p>
</blockquote>
<p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>
<p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>
<p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>
<p><strong>1）请求方法是以下三种方法之一：</strong></p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>若不满足以上条件，就属于非简单请求了。</p>
<p><strong>（1）简单请求过程：</strong></p>
<p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值</span><br><span class="line">Content-Type: text/html; charset=utf-8   // 表示文档类型</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>
<p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>Access-Control-Allow-Origin</code></p>
<p><strong>（2）非简单请求过程</strong></p>
<p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>
<p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>
<p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>
<ul>
<li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li>
<li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li>
</ul>
<p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>
<p>服务器回应的CORS的字段如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p><strong>在非简单请求中，至少需要设置以下字段：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Access-Control-Allow-Origin&#x27;  </span><br><span class="line">&#x27;Access-Control-Allow-Methods&#x27;</span><br><span class="line">&#x27;Access-Control-Allow-Headers&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>
<h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li>在请求中设置<code>withCredentials</code></li>
</ul>
<p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原生 xml 的设置方式</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// axios 设置方式</span><br><span class="line">axios.defaults.withCredentials = true;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Access-Control-Allow-Credentials</strong> 设置为 <code>true</code></li>
<li><strong>Access-Control-Allow-Origin</strong> 设置为 <code>false</code></li>
</ul>
<h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用 <code>&lt;script&gt;</code>标签没有跨域限制，通过 <code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<p>1）原生JS实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;;</span><br><span class="line">    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">    // 回调执行函数</span><br><span class="line">    function handleCallback(res) &#123;</span><br><span class="line">        alert(JSON.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>服务端返回如下（返回时即执行全局函数）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）Vue axios实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$http = axios;</span><br><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>后端node.js代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var querystring = require(&#x27;querystring&#x27;);</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var params = querystring.parse(req.url.split(&#x27;?&#x27;)[1]);</span><br><span class="line">    var fn = params.callback;</span><br><span class="line">    // jsonp返回设置</span><br><span class="line">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/javascript&#x27; &#125;);</span><br><span class="line">    res.write(fn + &#x27;(&#x27; + JSON.stringify(params) + &#x27;)&#x27;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>JSONP的缺点：</strong></p>
<ul>
<li>具有局限性， 仅支持get方法</li>
<li>不安全，可能会遭受XSS攻击</li>
</ul>
<h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>用法：postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<p>1）a.html：(domain1.com/a.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; rel=&quot;external nofollow&quot;  rel=&quot;external nofollow&quot;  style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;     </span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &#x27;aym&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http://www.domain2.com&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain2 ---&gt; &#x27; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）b.html：(domain2.com/b.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<p>1）nginx配置解决iconfont跨域</p>
<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）nginx反向代理接口跨域</p>
<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>
<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>
<p>nginx具体配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p><strong>1）非vue框架的跨域</strong></p>
<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<ul>
<li>前端代码：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:3000/login?user=admin&#x27;, true);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>中间件服务器代码：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(&#x27;/&#x27;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &#x27;http://www.domain2.com:8080&#x27;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#x27;Proxy server is listen at port 3000...&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>2）vue框架的跨域</strong></p>
<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>
<p>webpack.config.js部分配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &#x27;/login&#x27;,</span><br><span class="line">            target: &#x27;http://www.domain2.com:8080&#x27;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1）父窗口：(domain.com/a.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot; rel=&quot;external nofollow&quot; &gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    var user = &#x27;admin&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）子窗口：(child.domain.com/a.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    console.log(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1）a.html：(domain1.com/a.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; rel=&quot;external nofollow&quot;  rel=&quot;external nofollow&quot;  style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &#x27;#user=admin&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&#x27;data from c.html ---&gt; &#x27; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）b.html：(.domain2.com/b.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; rel=&quot;external nofollow&quot;  style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>3）c.html：(<code>http://www.domain1.com/c.html</code>)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&#x27;hello: &#x27; + location.hash.replace(&#x27;#user=&#x27;, &#x27;&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1）a.html：(domain1.com/a.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &#x27;http://www.domain1.com/proxy.html&#x27;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&#x27;&#x27;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&#x27;http://www.domain2.com/b.html&#x27;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）proxy.html：(domain1.com/proxy.html)</p>
<p>中间代理页，与a.html同域，内容为空即可。</p>
<p>3）b.html：(domain2.com/b.html)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &#x27;This is domain2 data!&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1）前端代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot; rel=&quot;external nofollow&quot; &gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&#x27;http://www.domain2.com:8080&#x27;);</span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&#x27;connect&#x27;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        console.log(&#x27;data from server: ---&gt; &#x27; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&#x27;disconnect&#x27;, function() &#123; </span><br><span class="line">        console.log(&#x27;Server socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）Nodejs socket后台：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var socket = require(&#x27;socket.io&#x27;);</span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;Content-type&#x27;: &#x27;text/html&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&#x27;connection&#x27;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        client.send(&#x27;hello：&#x27; + msg);</span><br><span class="line">        console.log(&#x27;data from client: ---&gt; &#x27; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&#x27;disconnect&#x27;, function() &#123;</span><br><span class="line">        console.log(&#x27;Client socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul>
<li>正向代理：</li>
</ul>
<p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>
<ul>
<li>反向代理：</li>
</ul>
<p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。</p>
<p>一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>
<p>两者区别如图示：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq7.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>
<h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>
<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>
<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>
<h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>
<li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
<li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
</ul>
<h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul>
<li>普通浏览器使用：event.stopPropagation()</li>
<li>IE浏览器使用：event.cancelBubble = true;</li>
</ul>
<h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="1）事件委托的概念"><a href="#1）事件委托的概念" class="headerlink" title="1）事件委托的概念"></a>1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
<h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul>
<li>减少内存消耗</li>
</ul>
<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
<ul>
<li>动态绑定事件</li>
</ul>
<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span><br><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  // 判断是否匹配目标元素</span><br><span class="line">  if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li>元素中，绑定事件委托的次数；</li>
<li>点击的最底层元素，到绑定事件元素之间的 <code>DOM</code>层数；</li>
</ul>
<p>在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li>
<li>尽量的减少绑定的层级，不在 <code>body</code>元素上，进行绑定</li>
<li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li>
</ul>
<h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    if (e.target.nodeName == &quot;A&quot;)</span><br><span class="line">        console.log(&quot;a&quot;);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    var node = e.target;</span><br><span class="line">    while (node.parentNode.nodeName != &quot;BODY&quot;) &#123;</span><br><span class="line">        if (node.nodeName == &quot;A&quot;) &#123;</span><br><span class="line">            console.log(&quot;a&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul>
<li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>
<li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li>
</ul>
<h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>首先执行同步代码，这属于宏任务</li>
<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>执行所有微任务</li>
<li>当执行完所有微任务后，如有必要会渲染页面</li>
<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li>
</ul>
<h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul>
<li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li>
<li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li>
</ul>
<h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq1.gif"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>
<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  throw new Error(&#x27;error&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq8.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq9.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq10.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p>
<p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</p>
<p>（3）<strong>Idle/Prepare</strong>：仅供内部使用。</p>
<p>（4）<strong>Poll</strong>（轮询阶段）：</p>
<ul>
<li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li>
<li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li>
</ul>
<p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p>
<p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p>
<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>
<li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout </code>回调</li>
<li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate </code>回调先执行了</li>
</ul>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/llq/llq11.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer21&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p>
<p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;timer1&#x27;)</span><br><span class="line"> Promise.resolve().then(function() &#123;</span><br><span class="line">   console.log(&#x27;promise1&#x27;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;nextTick&#x27;)</span><br><span class="line"> process.nextTick(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;nextTick&#x27;)</span><br><span class="line">   process.nextTick(() =&gt; &#123;</span><br><span class="line">     console.log(&#x27;nextTick&#x27;)</span><br><span class="line">     process.nextTick(() =&gt; &#123;</span><br><span class="line">       console.log(&#x27;nextTick&#x27;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p>
<p>顺序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//macro-task:script(全部的代码) setInterval setTimeout setImmediate I/O</span><br><span class="line">//micro-task:process.nextTick  Promise</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>
<ul>
<li><code>window </code>往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window </code>传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个</strong> <code>body</code> <strong>中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以下会先打印冒泡然后是捕获</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;冒泡&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获 &#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  true</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture </code>作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true </code>表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
<p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    console.log(&#x27;冒泡&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">)</span><br><span class="line">// 点击 node 只会执行上面的函数，该函数不会执行</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获 &#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  true</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<p><strong>（1）新生代算法</strong></p>
<p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<p><strong>（2）老生代算法</strong></p>
<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p>先来说下什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p>老生代中的空间很复杂，有如下几个空间</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  // TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span><br><span class="line">  RO_SPACE,    // 不变的对象空间</span><br><span class="line">  NEW_SPACE,   // 新生代用于 GC 复制算法的空间</span><br><span class="line">  OLD_SPACE,   // 老生代常驻对象空间</span><br><span class="line">  CODE_SPACE,  // 老生代代码对象空间</span><br><span class="line">  MAP_SPACE,   // 老生代 map 对象</span><br><span class="line">  LO_SPACE,    // 老生代大空间对象</span><br><span class="line">  NEW_LO_SPACE,  // 新生代大空间对象</span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
<h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul>
<li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h1 id="计算机网络面试题"><a href="#计算机网络面试题" class="headerlink" title="计算机网络面试题"></a>计算机网络面试题</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong>因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>发送的报文格式：</strong>Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>安全性：</strong>Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong>post 的参数传递支持更多的数据类型。</li>
</ul>
<h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h3><ul>
<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为是<strong>更新数据</strong>）</li>
<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>
</ul>
<h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p>
<ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p><strong>HTTP Responses Header 常见的响应头：</strong></p>
<ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<p>常见的 Content-Type 属性值有以下四种：</p>
<p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p>
<p>服务器向客户端发送数据格式类型：XML、HTML、JSON</p>
<h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>
<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>
<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>
<p><strong>产生较多304状态码的原因：</strong></p>
<ul>
<li>页面更新周期长或不更新</li>
<li>纯静态页面或强制生成静态html</li>
</ul>
<p><strong>304状态码出现过多会造成以下问题：</strong></p>
<ul>
<li>网站快照停止；</li>
<li>收录减少；</li>
<li>权重下降。</li>
</ul>
<h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h3><ul>
<li>GET: 向服务器获取数据；</li>
<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>
<li>PUT：上传文件，更新数据；</li>
<li>DELETE：删除服务器上的对象；</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>
<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>
</ul>
<h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6. OPTIONS请求方法及使用场景"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>
<p>OPTIONS方法是用于请求获得由 <code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>
</ul>
<h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</p>
<ul>
<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8. HTTP 1.1 和 HTTP 2.0 的区别"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><strong>二进制协议：</strong>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<p><strong>【1】队头堵塞：</strong></p>
<blockquote>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9. HTTP和HTTPS协议的区别"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</p>
<p>IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>
<ul>
<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li>
<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li>
<li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li>
<li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li>
<li>Google (chrome)：URL最大长度限制为 8182 个字符。</li>
</ul>
<p>主流的服务器对get方法中url的长度限制范围：</p>
<ul>
<li>Apache (Server)：能接受最大url长度为8192个字符。</li>
<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li>
</ul>
<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>
<h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p><strong>（1）解析URL：</strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<p><strong>（2）缓存判断：</strong>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p><strong>（3）DNS解析：</strong>下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p><strong>（4）获取MAC地址：</strong>当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>
<p><strong>（5）TCP三次握手：</strong>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p><strong>（6）HTTPS握手：</strong>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p><strong>（7）返回数据：</strong>当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p><strong>（8）页面渲染：</strong>浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>
<p><strong>（9）TCP四次挥手：</strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
<h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12. 对keep-alive的理解"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p>
<ul>
<li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送 <code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送 <code>Connection:close</code>字段；</li>
<li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 <code>Connection:close</code>首部字段。</li>
</ul>
<p>Keep-Alive的<strong>建立过程</strong>：</p>
<ul>
<li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li>
<li>服务器收到请求并处理 Connection字段</li>
<li>服务器回送Connection:Keep-Alive字段给客户端</li>
<li>客户端接收到Connection字段</li>
<li>Keep-Alive连接建立成功</li>
</ul>
<p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p>
<ul>
<li>客户端向服务器只是发送内容报文（不包含Connection字段）</li>
<li>服务器收到请求并处理</li>
<li>服务器返回客户端请求的资源并关闭连接</li>
<li>客户端接收资源，发现没有Connection字段，断开连接</li>
</ul>
<p><strong>客户端请求断开连接过程</strong>：</p>
<ul>
<li>客户端向服务器发送Connection:close字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送响应资源并断开连接</li>
<li>客户端接收资源并断开连接</li>
</ul>
<p>开启Keep-Alive的<strong>优点：</strong></p>
<ul>
<li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li>
<li>允许请求和应答的HTTP管线化；</li>
<li>降低拥塞控制 （TCP连接减少了）；</li>
<li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li>
<li>报告错误⽆需关闭TCP连；</li>
</ul>
<p>开启Keep-Alive的<strong>缺点</strong>：</p>
<ul>
<li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li>
</ul>
<h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13. 页面有多张图片，HTTP是怎样的加载表现？"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul>
<li>在 <strong>HTTP 1</strong>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li>
<li>在 <strong>HTTP 2</strong>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li>
</ul>
<h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14. HTTP2的头部压缩算法是怎样的？"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<p>具体来说:</p>
<ul>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li>
<li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl2.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15. HTTP请求报文的是什么样的？"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p>
<ul>
<li>请求⾏</li>
<li>请求头部</li>
<li>空⾏</li>
<li>请求体</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl3.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><strong>其中：</strong></p>
<p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。</p>
<p>（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。</li>
<li>Accept：客户端可识别的内容类型列表。</li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>
</ul>
<p>（3）请求体: post put等请求携带的数据</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl4.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16. HTTP响应报文的是什么样的？"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p>
<ul>
<li>响应⾏</li>
<li>响应头</li>
<li>空⾏</li>
<li>响应体</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl5.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<ul>
<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。</li>
<li>响应头：响应部⾸组成</li>
<li>响应体：服务器响应的数据</li>
</ul>
<h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17. HTTP协议的优点和缺点"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>
<p>HTTP协议具有以下<strong>优点</strong>：</p>
<ul>
<li>支持客户端/服务器模式</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
</ul>
<p>HTTP协议具有以下<strong>缺点</strong>：</p>
<ul>
<li><strong>无状态</strong>：HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>
<li><strong>明文传输</strong>：协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
<li><strong>不安全</strong></li>
</ul>
<p>（1）通信使用明文（不加密），内容可能会被窃听；</p>
<p>（2）不验证通信方的身份，因此有可能遭遇伪装；</p>
<p>（3）无法证明报文的完整性，所以有可能已遭篡改；</p>
<h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18. 说一下HTTP 3.0"></a>18. 说一下HTTP 3.0</h3><p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p>
<ol>
<li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li>
<li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li>
<li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li>
<li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li>
</ol>
<h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19. HTTP协议的性能怎么样"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP/IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p>
<ul>
<li><strong>长连接</strong></li>
</ul>
<p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。</p>
<p>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。</p>
<p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p>
<p>对于不同版本的采用不同的连接方式：</p>
<ul>
<li>在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li>
<li>在HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl6.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<ul>
<li><strong>管道网络传输</strong></li>
</ul>
<p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>
<p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p>
<ul>
<li><strong>队头堵塞</strong></li>
</ul>
<p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p>
<p><strong>队头阻塞的解决方案：</strong></p>
<p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。</p>
<p>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>
<h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20. URL有哪些组成部分"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：<strong><a class="link"   href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" >http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为“<a class="link"   href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/" >www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21. 与缓存相关的HTTP请求头有哪些"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p>
<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
<p>协商缓存：</p>
<ul>
<li>Etag、If-None-Match</li>
<li>Last-Modified、If-Modified-Since</li>
</ul>
<h2 id="二、HTTPS协议"><a href="#二、HTTPS协议" class="headerlink" title="二、HTTPS协议"></a>二、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>
<h3 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS/SSL的工作原理"></a>2. TLS/SSL的工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>基于散列函数验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl7.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p>
<p><strong>特点</strong>：在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p>
<h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p>
<p><strong>特点</strong>：对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>
<h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>
<p><strong>特点</strong>：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p>
<p>综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p>
<h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl8.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p>
<ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p>
<ul>
<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>
<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>
</ul>
<p>HTTPS的<strong>缺点</strong>如下：</p>
<ul>
<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>
<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高；</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>
<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>
</ul>
<h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. HTTPS是如何保证安全的？</h3><p>先理解两个概念：</p>
<ul>
<li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</li>
<li>⾮对称加密：</li>
</ul>
<ol>
<li>私钥 + 公钥= 密钥对</li>
<li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li>
<li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li>
<li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li>
</ol>
<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p>
<p><strong>解决⽅案：</strong></p>
<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p>
<p>此时⼜带来⼀个问题，中间⼈问题：</p>
<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。</p>
<p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>
<p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。</p>
<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</p>
<h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p>
<h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p>
<h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p>
<h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong></p>
<p>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
<h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong></p>
<p>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>
<li>未登陆的用户访问用户中心重定向到登录页面。</li>
<li>访问404页面重新定向到首页。</li>
</ul>
<h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p>303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p>
<p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p>
<p>注意：</p>
<ul>
<li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li>
<li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li>
</ul>
<h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p>浏览器缓存相关。</p>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p>
<p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p>
<p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p>
<h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p>307表示临时重定向。该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p>
<p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p>
<h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
<h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p>
<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p>以下情况会出现401：</p>
<ul>
<li>401.1 - 登录失败。</li>
<li>401.2 - 服务器配置导致登录失败。</li>
<li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li>
<li>401.4 - 筛选器授权失败。</li>
<li>401.5 - ISAPI/CGI 应用程序授权失败。</li>
<li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p>
<p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p>
<ul>
<li>403.1 - 执行访问被禁止。</li>
<li>403.2 - 读访问被禁止。</li>
<li>403.3 - 写访问被禁止。</li>
<li>403.4 - 要求 SSL。</li>
<li>403.5 - 要求 SSL 128。</li>
<li>403.6 - IP 地址被拒绝。</li>
<li>403.7 - 要求客户端证书。</li>
<li>403.8 - 站点访问被拒绝。</li>
<li>403.9 - 用户数过多。</li>
<li>403.10 - 配置无效。</li>
<li>403.11 - 密码更改。</li>
<li>403.12 - 拒绝访问映射表。</li>
<li>403.13 - 客户端证书被吊销。</li>
<li>403.14 - 拒绝目录列表。</li>
<li>403.15 - 超出客户端访问许可。</li>
<li>403.16 - 客户端证书不受信任或无效。</li>
<li>403.17 - 客户端证书已过期或尚未生效</li>
<li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<p>以下情况会出现404：</p>
<ul>
<li>404.0 -（无） – 没有找到文件或目录。</li>
<li>404.1 - 无法在所请求的端口上访问 Web 站点。</li>
<li>404.2 - Web 服务扩展锁定策略阻止本请求。</li>
<li>404.3 - MIME 映射策略阻止本请求。</li>
</ul>
<h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p>
<h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p>
<ul>
<li>502.1 - CGI （通用网关接口）应用程序超时。</li>
<li>502.2 - CGI （通用网关接口）应用程序出错。</li>
</ul>
<h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>服务器停机维护时，主动用503响应请求；</li>
<li>nginx 设置限速，超过限速，会返回503。</li>
</ul>
<h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p>
<p>使用场景：代码执行时间超时，或者发生了死循环。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>1）2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<p><strong>（2）3XX 重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<p><strong>（3）4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<p><strong>（4）5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，307，303，302的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。</p>
<h2 id="四、DNS协议介绍"><a href="#四、DNS协议介绍" class="headerlink" title="四、DNS协议介绍"></a>四、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
<h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p>
<p>（1）在区域传输的时候使用TCP协议</p>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。</li>
</ul>
<p>（2）在域名解析的时候使用UDP协议</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
<h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p>
<ul>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
</ul>
<p>比如要查询 <strong><a class="link"   href="http://www.baidu.com/" >www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">（Name，Value，Type，TTL）</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p>
<ul>
<li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了 <code>OSI</code>参考模型。</p>
<h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>
<ul>
<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到 <code>http(hyper text transfer protocol)(超文本传输协议)</code>或者 <code>https</code>在后端设计数据接口时，我们常常使用到这个协议。</li>
<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如 <strong>百度网盘 迅雷</strong>应该是基于此协议的。</li>
<li><code>SMTP</code>是 <code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>
</ul>
<h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>在项目开发中，为了方便数据传输，可以使用 <code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>
<h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>
<h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过 <code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的 <code>IP</code>层。这一层就是我们经常说的 <code>IP</code>协议层。<code>IP</code>协议是 <code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>
<h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>
<h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p><strong>OSI七层模型通信特点：对等通信</strong></p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<h3 id="2-TCP-IP五层协议"><a href="#2-TCP-IP五层协议" class="headerlink" title="2. TCP/IP五层协议"></a>2. TCP/IP五层协议</h3><p><code>TCP/IP</code>五层协议和 <code>OSI</code>的七层协议对应关系如下：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl9.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<ul>
<li>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li>
<li>**传输层 (transport layer)**：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</li>
<li><ul>
<li>**传输控制协议 (Transmission Control Protocol，TCP)**：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>**用户数据报协议 (User Datagram Protocol，UDP)**：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li>
<li>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li>
<li>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li>
</ul>
<p>从上图中可以看出，<code>TCP/IP</code>模型比 <code>OSI</code>模型更加简洁，它把 <code>应用层/表示层/会话层</code>全部整合为了 <code>应用层</code>。</p>
<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：</p>
<p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl10.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="六、TCP与UDP"><a href="#六、TCP与UDP" class="headerlink" title="六、TCP与UDP"></a>六、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：</p>
<p><strong>（1）UDP</strong></p>
<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它的特点如下：</p>
<p><strong>1）面向无连接</strong></p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<p><strong>2）有单播，多播，广播的功能</strong></p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<p><strong>3）面向报文</strong></p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<p><strong>4）不可靠性</strong></p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl11.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>
<p><strong>（2）TCP</strong></p>
<p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>
<p>它有以下几个特点：</p>
<p><strong>1）面向连接</strong></p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<p><strong>2）仅支持单播传输</strong></p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<p><strong>3）面向字节流</strong></p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<p><strong>4）可靠传输</strong></p>
<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p><strong>5）提供拥塞控制</strong></p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>
<p><strong>6）提供全双工通信</strong></p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul>
<li><strong>TCP应用场景</strong>： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li><strong>UDP应用场景</strong>： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p>
<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>
<ul>
<li>慢启动（慢开始）</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p><strong>（1）慢启动（慢开始）</strong></p>
<ul>
<li>在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）</li>
<li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li>
<li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</li>
<li><ul>
<li>当cnwd &lt; ssthresh，使用慢开始算法</li>
<li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>
</ul>
</li>
</ul>
<p><strong>（2）拥塞避免</strong></p>
<ul>
<li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li>
<li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl12.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<ul>
<li>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li>
</ul>
<p><strong>（3）快速重传</strong></p>
<ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>
</ul>
<p><strong>（4）快速恢复</strong></p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li>
</ul>
<h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<ul>
<li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li>
<li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li>
<li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li>
<li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li>
</ul>
<h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
<h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl13.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>
</ul>
<blockquote>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
</blockquote>
<ul>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
</ul>
<blockquote>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y</p>
</blockquote>
<ul>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<blockquote>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</blockquote>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>简单来说就是以下三步：</strong></p>
<ul>
<li><strong>第一次握手</strong>：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
<li><strong>第二次握手</strong>：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
<li><strong>第三次握手</strong>：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/wl/wl14.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<blockquote>
<p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
</blockquote>
<ul>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<blockquote>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
</blockquote>
<ul>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<blockquote>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
</blockquote>
<ul>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
<blockquote>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
</blockquote>
<p>那为什么需要四次挥手呢？</p>
<blockquote>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
</blockquote>
<p>简单来说就是以下四步：</p>
<ul>
<li><strong>第一次挥手</strong>：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次挥手</strong>：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>
<h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理?"></a>10. TCP粘包是怎么回事，如何处理?</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲大小见 socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p>
<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p>
<p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p>
<p>A. 先接收到 data1, 然后接收到 data2 .</p>
<p>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.</p>
<p>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.</p>
<p>D. ⼀次性接收到了 data1 和 data2 的全部数据.</p>
<p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p>
<ul>
<li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li>
<li><strong>关闭Nagle算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li>
<li><strong>进⾏封包/拆包</strong>：封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li>
</ul>
<h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么udp不会粘包？</h3><ul>
<li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li>
</ul>
<h2 id="七、WebSocket"><a href="#七、WebSocket" class="headerlink" title="七、WebSocket"></a>七、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>
<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>
<p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p>
<p><strong>WebSocket 特点的如下：</strong></p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据‘’</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<p><strong>Websocket的使用方法如下：</strong></p>
<p>在客户端中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br><span class="line">let ws = new WebSocket(&#x27;ws://localhost:9999&#x27;);</span><br><span class="line">// 在客户端与服务端建立连接后触发</span><br><span class="line">ws.onopen = function() &#123;</span><br><span class="line">    console.log(&quot;Connection open.&quot;); </span><br><span class="line">    ws.send(&#x27;hello&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 在服务端给客户端发来消息的时候触发</span><br><span class="line">ws.onmessage = function(res) &#123;</span><br><span class="line">    console.log(res);       // 打印的是MessageEvent对象</span><br><span class="line">    console.log(res.data);  // 打印的是收到的消息</span><br><span class="line">&#125;;</span><br><span class="line">// 在客户端与服务端建立关闭后触发</span><br><span class="line">ws.onclose = function(evt) &#123;</span><br><span class="line">  console.log(&quot;Connection closed.&quot;);</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>
<p><strong>短轮询的基本思路</strong>：浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>
<p><strong>长轮询的基本思路</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<p><strong>SSE 的基本思想</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p>
<p>WebSocket 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>
<p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p>
<p>对于这四种即使通信协议，从性能的角度来看：</p>
<p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p>
<p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p>
<p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p>
<p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>
<h1 id="代码输出面试题"><a href="#代码输出面试题" class="headerlink" title="代码输出面试题"></a>代码输出面试题</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong>代码输出结果</strong>也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p>
<h2 id="一、异步-amp-事件循环"><a href="#一、异步-amp-事件循环" class="headerlink" title="一、异步&amp;事件循环"></a>一、异步&amp;事件循环</h2><h3 id="1-代码输出结果"><a href="#1-代码输出结果" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p>
<h3 id="2-代码输出结果"><a href="#2-代码输出结果" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;)</span><br><span class="line">  resolve(&#x27;resolve1&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;1&#x27;, promise1);</span><br><span class="line">console.log(&#x27;2&#x27;, promise2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise1</span><br><span class="line">1 Promise&#123;&lt;resolved&gt;: resolve1&#125;</span><br><span class="line">2 Promise&#123;&lt;pending&gt;&#125;</span><br><span class="line">resolve1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p>
<p>代码执行过程如下：</p>
<ol>
<li>script是一个宏任务，按照顺序执行这些代码；</li>
<li>首先进入Promise，执行该构造函数中的代码，打印 <code>promise1</code>；</li>
<li>碰到 <code>resolve</code>函数, 将 <code>promise1</code>的状态改变为 <code>resolved</code>, 并将结果保存下来；</li>
<li>碰到 <code>promise1.then</code>这个微任务，将它放入微任务队列；</li>
<li><code>promise2</code>是一个新的状态为 <code>pending</code>的 <code>Promise</code>；</li>
<li>执行同步代码1， 同时打印出 <code>promise1</code>的状态是 <code>resolved</code>；</li>
<li>执行同步代码2，同时打印出 <code>promise2</code>的状态是 <code>pending</code>；</li>
<li>宏任务执行完毕，查找微任务队列，发现 <code>promise1.then</code>这个微任务且状态为 <code>resolved</code>，执行它。</li>
</ol>
<h3 id="3-代码输出结果"><a href="#3-代码输出结果" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;timerStart&quot;);</span><br><span class="line">    resolve(&quot;success&quot;);</span><br><span class="line">    console.log(&quot;timerEnd&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">timerStart</span><br><span class="line">timerEnd</span><br><span class="line">success</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ul>
<li>首先遇到Promise构造函数，会先执行里面的内容，打印 1；</li>
<li>遇到定时器 <code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li>
<li>继续向下执行，打印出2；</li>
<li>由于 <code>Promise</code>的状态此时还是 <code>pending</code>，所以 <code>promise.then</code>先不执行；</li>
<li>继续执行下面的同步任务，打印出4；</li>
<li>此时微任务队列没有任务，继续执行下一轮宏任务，执行 <code>steTimeout</code>；</li>
<li>首先执行 <code>timerStart</code>，然后遇到了 <code>resolve</code>，将 <code>promise</code>的状态改为 <code>resolved</code>且保存结果并将之前的 <code>promise.then</code>推入微任务队列，再执行 <code>timerEnd</code>；</li>
<li>执行完这个宏任务，就去执行微任务 <code>promise.then</code>，打印出 <code>resolve</code>的结果。</li>
</ul>
<h3 id="4-代码输出结果"><a href="#4-代码输出结果" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;);</span><br><span class="line">  const timer2 = setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer2&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;);</span><br><span class="line">const timer1 = setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer1&#x27;)</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(&#x27;start&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">promise1</span><br><span class="line">timer1</span><br><span class="line">promise2</span><br><span class="line">timer2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ol>
<li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li>
<li>执行timer1，它是一个宏任务，加入宏任务队列</li>
<li>继续执行下面的同步代码，打印出 <code>start</code></li>
<li>这样第一轮宏任务就执行完了，开始执行微任务 <code>Promise.resolve().then</code>，打印出 <code>promise1</code></li>
<li>遇到 <code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是 <code>timer1</code>、<code>timer2</code>；</li>
<li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器 <code>timer1</code>，打印 <code>timer1</code>；</li>
<li>遇到 <code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li>
<li>开始执行微任务队列中的任务，打印 <code>promise2</code>；</li>
<li>最后执行宏任务 <code>timer2</code>定时器，打印出 <code>timer2</code>；</li>
</ol>
<h3 id="5-代码输出结果"><a href="#5-代码输出结果" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;success1&#x27;);</span><br><span class="line">    reject(&#x27;error&#x27;);</span><br><span class="line">    resolve(&#x27;success2&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then:&#x27;, res);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch:&#x27;, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">then：success1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由 <code>pending</code>变为 <code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p>
<h3 id="6-代码输出结果"><a href="#6-代码输出结果" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>
<h3 id="7-代码输出结果"><a href="#7-代码输出结果" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;success&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(() =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">  console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise1 Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line"></span><br><span class="line">Uncaught (in promise) Error: error!!!</span><br><span class="line">promise1 Promise &#123;&lt;fulfilled&gt;: &quot;success&quot;&#125;</span><br><span class="line">promise2 Promise &#123;&lt;rejected&gt;: Error: error!!&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-代码输出结果"><a href="#8-代码输出结果" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   </span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p>
<p>上面的输出结果之所以依次打印出1和2，是因为 <code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成 <code>resolve(2)</code>，被最后的then打印输出2。</p>
<h3 id="9-代码输出结果"><a href="#9-代码输出结果" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  return new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(&quot;then: &quot;, res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&quot;catch: &quot;, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;then: &quot; &quot;Error: error!!!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的 <code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了 <code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p>
<h3 id="10-代码输出结果"><a href="#10-代码输出结果" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  return promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(console.err)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<h3 id="11-代码输出结果"><a href="#11-代码输出结果" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或 <code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p>
<p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将 <code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p>
<h3 id="12-代码输出结果"><a href="#12-代码输出结果" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.reject(&#x27;err!!!&#x27;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;success&#x27;, res)</span><br><span class="line">  &#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;error&#x27;, err)</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch&#x27;, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error err!!!</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们知道，<code>.then</code>函数中的两个参数：</p>
<ul>
<li>第一个参数是用来处理Promise成功的函数</li>
<li>第二个则是处理失败的函数</li>
</ul>
<p>也就是说 <code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>在这道题中，错误直接被 <code>then</code>的第二个参数捕获了，所以就不会被 <code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p>
<p>但是，如果是像下面这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  &#125;, function fail1 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail1&#x27;, err)</span><br><span class="line">  &#125;).catch(function fail2 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail2&#x27;, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在 <code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的 <code>catch</code>捕获到。</p>
<h3 id="13-代码输出结果"><a href="#13-代码输出结果" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#x27;1&#x27;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">Promise.resolve(&#x27;2&#x27;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally2&#x27;)</span><br><span class="line">    return &#x27;我是finally2返回的值&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally2后面的then函数&#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">finally2</span><br><span class="line">finally</span><br><span class="line">finally2后面的then函数 2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p>
<ul>
<li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在 <code>.finally()</code>函数中是无法知道Promise最终的状态是 <code>resolved</code>还是 <code>rejected</code>的</li>
<li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li>
<li>finally本质上是then方法的特例</li>
</ul>
<p><code>.finally()</code>的错误捕获：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#x27;1&#x27;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally1&#x27;)</span><br><span class="line">    throw new Error(&#x27;我是finally中抛出的异常&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally后面的then函数&#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获错误&#x27;, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;finally1&#x27;</span><br><span class="line">&#x27;捕获错误&#x27; Error: 我是finally中抛出的异常</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="14-代码输出结果"><a href="#14-代码输出结果" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res =&gt; console.log(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[1, 2, 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p>
<p>之后再使用 <code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p>
<h3 id="15-代码输出结果"><a href="#15-代码输出结果" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">function runReject (x) &#123;</span><br><span class="line">  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])</span><br><span class="line">       .then(res =&gt; console.log(res))</span><br><span class="line">       .catch(err =&gt; console.log(err))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1s后输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">// 2s后输出</span><br><span class="line">2</span><br><span class="line">Error: 2</span><br><span class="line">// 4s后输出</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是 <code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入 <code>.then()</code>的第一个回调函数参数中。会被 <code>.then()</code>的第二个回调函数捕获。</p>
<h3 id="16-代码输出结果"><a href="#16-代码输出结果" class="headerlink" title="16. 代码输出结果"></a>16. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.race([runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(&#x27;result: &#x27;, res))</span><br><span class="line">  .catch(err =&gt; console.log(err))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">&#x27;result: &#x27; 1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p>
<h3 id="17-代码输出结果"><a href="#17-代码输出结果" class="headerlink" title="17. 代码输出结果"></a>17. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runAsync(x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt;</span><br><span class="line">    setTimeout(() =&gt; r(x, console.log(x)), 1000)</span><br><span class="line">  );</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line">function runReject(x) &#123;</span><br><span class="line">  const p = new Promise((res, rej) =&gt;</span><br><span class="line">    setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)</span><br><span class="line">  );</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line">Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(&quot;result: &quot;, res))</span><br><span class="line">  .catch(err =&gt; console.log(err));</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">Error: 0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p>
<p>注意：<code>all</code>和 <code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p>
<h3 id="18-代码输出结果"><a href="#18-代码输出结果" class="headerlink" title="18. 代码输出结果"></a>18. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">console.log(&#x27;start&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行函数中的同步代码 <code>async1 start</code>，之后遇到了 <code>await</code>，它会阻塞 <code>async1</code>后面代码的执行，因此会先去执行 <code>async2</code>中的同步代码 <code>async2</code>，然后跳出 <code>async1</code>；</li>
<li>跳出 <code>async1</code>函数后，执行同步代码 <code>start</code>；</li>
<li>在一轮宏任务全部执行完之后，再来执行 <code>await</code>后面的内容 <code>async1 end</code>。</li>
</ol>
<p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p>
<h3 id="19-代码输出结果"><a href="#19-代码输出结果" class="headerlink" title="19. 代码输出结果"></a>19. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer2&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer3&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(&quot;start&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码的执行过程如下：</p>
<ol>
<li>首先进入 <code>async1</code>，打印出 <code>async1 start</code>；</li>
<li>之后遇到 <code>async2</code>，进入 <code>async2</code>，遇到定时器 <code>timer2</code>，加入宏任务队列，之后打印 <code>async2</code>；</li>
<li>由于 <code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器 <code>timer3</code>，将其加入宏任务队列，之后打印 <code>start</code>；</li>
<li>然后执行<code>async2</code>后面的代码，打印出 <code>async1 end</code>，遇到定时器<code>timer1</code>，将其加入宏任务队列；</li>
<li>最后，宏任务队列有三个任务，先后顺序为 <code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li>
</ol>
<h3 id="20-代码输出结果"><a href="#20-代码输出结果" class="headerlink" title="20. 代码输出结果"></a>20. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;);</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#x27;async1 success&#x27;);</span><br><span class="line">  return &#x27;async1 end&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;srcipt start&#x27;)</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;srcipt end&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里需要注意的是在 <code>async1</code>中 <code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是 <code>pending</code>状态，所以在 <code>await</code>之后的内容是不会执行的，包括 <code>async1</code>后面的 <code>.then</code>。</p>
<h3 id="21-代码输出结果"><a href="#21-代码输出结果" class="headerlink" title="21. 代码输出结果"></a>21. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;);</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve(&#x27;promise1 resolve&#x27;)</span><br><span class="line">  &#125;).then(res =&gt; console.log(res))</span><br><span class="line">  console.log(&#x27;async1 success&#x27;);</span><br><span class="line">  return &#x27;async1 end&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;srcipt start&#x27;)</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;srcipt end&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里是对上面一题进行了改造，加上了resolve。</p>
<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise1 resolve</span><br><span class="line">async1 success</span><br><span class="line">async1 end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="22-代码输出结果"><a href="#22-代码输出结果" class="headerlink" title="22. 代码输出结果"></a>22. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ol>
<li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li>
<li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li>
<li>之后执行函数async1，首先打印出async1 start；</li>
<li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li>
<li>然后跳出async1和async2，遇到Promise，打印出promise1；</li>
<li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li>
<li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li>
<li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li>
</ol>
<h3 id="23-代码输出结果"><a href="#23-代码输出结果" class="headerlink" title="23. 代码输出结果"></a>23. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  return &#x27;async1 success&#x27;</span><br><span class="line">&#125;</span><br><span class="line">async function async2 () &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">    reject(&#x27;error&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async2</span><br><span class="line">Uncaught (in promise) error</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p>
<p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  await Promise.reject(&#x27;error!!!&#x27;).catch(e =&gt; console.log(e))</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  return Promise.resolve(&#x27;async1 success&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样的输出结果就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">error!!!</span><br><span class="line">async1</span><br><span class="line">async1 success</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="24-代码输出结果"><a href="#24-代码输出结果" class="headerlink" title="24. 代码输出结果"></a>24. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(7);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(5);</span><br><span class="line">            resolve(6);</span><br><span class="line">            console.log(p)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(2);</span><br><span class="line">    p.then((arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">Promise&#123;&lt;resolved&gt;: 1&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码的执行过程如下：</p>
<ol>
<li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li>
<li>遇到了定时器，将其加入宏任务队列；</li>
<li>执行Promise p中的resolve，状态变为resolved，返回值为1；</li>
<li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li>
<li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li>
<li>执行外面的代码，打印出4；</li>
<li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li>
<li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以 <code>resolve(6)</code>不会再执行；</li>
<li>最后 <code>console.log(p)</code>打印出 <code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li>
</ol>
<h3 id="25-代码输出结果"><a href="#25-代码输出结果" class="headerlink" title="25. 代码输出结果"></a>25. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const async1 = async () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#x27;async1 end&#x27;)</span><br><span class="line">  return &#x27;async1 success&#x27;</span><br><span class="line">&#125; </span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">async1().then(res =&gt; console.log(res));</span><br><span class="line">console.log(&#x27;script end&#x27;);</span><br><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .catch(4)</span><br><span class="line">  .then(res =&gt; console.log(res))</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer2&#x27;)</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">1</span><br><span class="line">timer2</span><br><span class="line">timer1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行同步带吗，打印出script start；</li>
<li>遇到定时器timer1将其加入宏任务队列；</li>
<li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li>
<li>然后执行同步代码，打印出script end；</li>
<li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li>
<li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li>
</ol>
<h3 id="26-代码输出结果"><a href="#26-代码输出结果" class="headerlink" title="26. 代码输出结果"></a>26. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;resolve3&#x27;);</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  resolve(&#x27;resovle1&#x27;);</span><br><span class="line">  resolve(&#x27;resolve2&#x27;);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)  // resolve1</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(p1)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).finally(res =&gt; &#123;</span><br><span class="line">  console.log(&#x27;finally&#x27;, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>执行结果为如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">resolve1</span><br><span class="line">finally  undefined</span><br><span class="line">timer1</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="27-代码输出结果"><a href="#27-代码输出结果" class="headerlink" title="27. 代码输出结果"></a>27. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;3&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;7&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;9&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;10&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;11&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;12&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>（1）第一轮事件循环流程分析如下：</strong></p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到 <code>console.log</code>，输出1。</li>
<li>遇到 <code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为 <code>setTimeout1</code>。</li>
<li>遇到 <code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为 <code>process1</code>。</li>
<li>遇到 <code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为 <code>then1</code>。</li>
<li>又遇到了 <code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为 <code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了 <code>process1</code>和 <code>then1</code>两个微任务：</p>
<ul>
<li>执行 <code>process1</code>，输出6。</li>
<li>执行 <code>then1</code>，输出8。</li>
</ul>
<p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p>
<p><strong>（2）第二轮时间循环从</strong> <code>setTimeout1</code><strong>宏任务开始：</strong></p>
<ul>
<li>首先输出2。接下来遇到了 <code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为 <code>process2</code>。</li>
<li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为 <code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<p>第二轮事件循环宏任务结束，发现有 <code>process2</code>和 <code>then2</code>两个微任务可以执行：</p>
<ul>
<li>输出3。</li>
<li>输出5。</li>
</ul>
<p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>
<p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p>
<ul>
<li>直接输出9。</li>
<li>将 <code>process.nextTick()</code>分发到微任务Event Queue中。记为 <code>process3</code>。</li>
<li>直接执行 <code>new Promise</code>，输出11。</li>
<li>将 <code>then</code>分发到微任务Event Queue中，记为 <code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<p>第三轮事件循环宏任务执行结束，执行两个微任务 <code>process3</code>和 <code>then3</code>：</p>
<ul>
<li>输出10。</li>
<li>输出12。</li>
</ul>
<p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<h3 id="28-代码输出结果"><a href="#28-代码输出结果" class="headerlink" title="28. 代码输出结果"></a>28. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt;  &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">  resolve(4)</span><br><span class="line">&#125;).then(d =&gt; console.log(d))</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(5)</span><br><span class="line">  new Promise(resolve =&gt;  &#123;</span><br><span class="line">    resolve(6)</span><br><span class="line">  &#125;).then(d =&gt; console.log(d))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(7)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(8)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行script代码，打印出1；</li>
<li>遇到第一个定时器，加入到宏任务队列；</li>
<li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器，加入到宏任务队列；</li>
<li>遇到第三个定时器，加入到宏任务队列；</li>
<li>继续执行script代码，打印出8，第一轮执行结束；</li>
<li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li>
<li>开始执行宏任务队列，执行第一个定时器，打印出2；</li>
<li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li>
<li>执行微任务队列，打印出6；</li>
<li>执行宏任务队列中的最后一个定时器，打印出7。</li>
</ol>
<h3 id="29-代码输出结果"><a href="#29-代码输出结果" class="headerlink" title="29. 代码输出结果"></a>29. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">  </span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(4)</span><br><span class="line">  resolve(5)</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(7);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行scrip代码，打印出1；</li>
<li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li>
<li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li>
<li>执行script代码，打印出7，至此第一轮执行完成；</li>
<li>指定微任务队列中的代码，打印出resolve的结果：5；</li>
<li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li>
<li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li>
<li>继续执行宏任务队列中的第二个定时器，打印出6。</li>
</ol>
<h3 id="30-代码输出结果"><a href="#30-代码输出结果" class="headerlink" title="30. 代码输出结果"></a>30. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;);</span><br><span class="line">    throw &#x27;Error&#x27;;</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;3&#x27;);</span><br><span class="line">    throw &#x27;Error&#x27;;</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;4&#x27;);</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;5&#x27;);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>执行结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">5 </span><br><span class="line">6</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p>
<h3 id="31-代码输出结果"><a href="#31-代码输出结果" class="headerlink" title="31. 代码输出结果"></a>31. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">  console.log(4);</span><br><span class="line">  new Promise((resove, reject) =&gt; &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">    setTimeout(() =&gt;  &#123;</span><br><span class="line">      console.log(6);</span><br><span class="line">    &#125;, 10);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(7);</span><br><span class="line">console.log(8);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码执行过程如下：</p>
<ol>
<li>首先遇到定时器，将其加入到宏任务队列；</li>
<li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li>
<li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li>
<li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li>
<li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li>
<li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li>
</ol>
<p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p>
<h2 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h2><h3 id="1-代码输出结果-1"><a href="#1-代码输出结果-1" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo() &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  doFoo: doFoo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = 2; </span><br><span class="line">obj.doFoo()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：2</p>
<p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p>
<h3 id="2-代码输出结果-1"><a href="#2-代码输出结果-1" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  say: () =&gt; &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say() </span><br><span class="line"></span><br><span class="line">var anotherObj = &#123; a: 30 &#125; </span><br><span class="line">obj.say.apply(anotherObj) </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：10 10</p>
<p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p>
<p>但是，如果是普通函数，那么就会有完全不一样的结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10  </span><br><span class="line">var obj = &#123;  </span><br><span class="line">  a: 20,  </span><br><span class="line">  say()&#123;</span><br><span class="line">    console.log(this.a)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">obj.say()   </span><br><span class="line">var anotherObj=&#123;a:30&#125;   </span><br><span class="line">obj.say.apply(anotherObj)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：20 30</p>
<p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p>
<h3 id="3-代码输出结果-1"><a href="#3-代码输出结果-1" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">a.call(null);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>打印结果：window对象</p>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">a.call(null); // null</span><br><span class="line">a.call(undefined); // undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-代码输出结果-1"><a href="#4-代码输出结果-1" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &#x27;cuggz&#x27;, </span><br><span class="line">  fun: function()&#123; </span><br><span class="line">     console.log(this.name); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">obj.fun()     // cuggz</span><br><span class="line">new obj.fun() // undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-代码输出结果-1"><a href="#5-代码输出结果-1" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   say: function() &#123;</span><br><span class="line">     var f1 = () =&gt;  &#123;</span><br><span class="line">       console.log(&quot;1111&quot;, this);</span><br><span class="line">     &#125;</span><br><span class="line">     f1();</span><br><span class="line">   &#125;,</span><br><span class="line">   pro: &#123;</span><br><span class="line">     getPro:() =&gt;  &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = obj.say;</span><br><span class="line">o();</span><br><span class="line">obj.say();</span><br><span class="line">obj.pro.getPro();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 window对象</span><br><span class="line">1111 obj对象</span><br><span class="line">window对象</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>解析：</strong></p>
<ol>
<li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li>
<li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li>
<li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li>
</ol>
<h3 id="6-代码输出结果-1"><a href="#6-代码输出结果-1" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: &quot;bar&quot;,</span><br><span class="line">    func: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(this.foo);  </span><br><span class="line">        console.log(self.foo);  </span><br><span class="line">        (function() &#123;</span><br><span class="line">            console.log(this.foo);  </span><br><span class="line">            console.log(self.foo);  </span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：bar bar undefined bar</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先func是由myObject调用的，this指向myObject。又因为var self = this;所以self指向myObject。</li>
<li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li>
</ol>
<h3 id="7-代码输出问题"><a href="#7-代码输出问题" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.number = 2;</span><br><span class="line">var obj = &#123;</span><br><span class="line"> number: 3,</span><br><span class="line"> db1: (function()&#123;</span><br><span class="line">   console.log(this);</span><br><span class="line">   this.number *= 4;</span><br><span class="line">   return function()&#123;</span><br><span class="line">     console.log(this);</span><br><span class="line">     this.number *= 5;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">var db1 = obj.db1;</span><br><span class="line">db1();</span><br><span class="line">obj.db1();</span><br><span class="line">console.log(obj.number);     // 15</span><br><span class="line">console.log(window.number);  // 40</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p>
<ol>
<li>执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；</li>
<li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。</li>
</ol>
<h3 id="8-代码输出结果-1"><a href="#8-代码输出结果-1" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  length: 5,</span><br><span class="line">  method: function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">    arguments[0]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">obj.method(fn, 1);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： 10 2</p>
<p><strong>解析：</strong></p>
<ol>
<li>第一次执行fn()，this指向window对象，输出10。</li>
<li>第二次执行arguments0，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li>
</ol>
<h3 id="9-代码输出结果-1"><a href="#9-代码输出结果-1" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function printA()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a:2,</span><br><span class="line">  foo:printA,</span><br><span class="line">  bar:function()&#123;</span><br><span class="line">    printA();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br><span class="line">obj.bar(); // 1</span><br><span class="line">var foo = obj.foo;</span><br><span class="line">foo(); // 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： 2 1 1</p>
<p><strong>解析：</strong></p>
<ol>
<li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li>
<li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li>
<li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li>
</ol>
<h3 id="10-代码输出结果-1"><a href="#10-代码输出结果-1" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 3;</span><br><span class="line">var y = 4;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 6,</span><br><span class="line">    getX: function() &#123;</span><br><span class="line">        var x = 5;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return this.x;</span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;,</span><br><span class="line">    getY: function() &#123;</span><br><span class="line">        var y = 7;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getX()) // 3</span><br><span class="line">console.log(obj.getY()) // 6</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：3 6</p>
<p><strong>解析：</strong></p>
<ol>
<li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li>
<li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li>
</ol>
<h3 id="11-代码输出结果-1"><a href="#11-代码输出结果-1" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10; </span><br><span class="line">var obt = &#123; </span><br><span class="line">  a: 20, </span><br><span class="line">  fn: function()&#123; </span><br><span class="line">    var a = 30; </span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">obt.fn();  // 20</span><br><span class="line">obt.fn.call(); // 10</span><br><span class="line">(obt.fn)(); // 20</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： 20 10 20</p>
<p><strong>解析：</strong></p>
<ol>
<li>obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li>
<li>obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li>
<li>(obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于 obt.fn()，所以会打印出 20；</li>
</ol>
<h3 id="12-代码输出结果-1"><a href="#12-代码输出结果-1" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a(xx)&#123;</span><br><span class="line">  this.x = xx;</span><br><span class="line">  return this</span><br><span class="line">&#125;;</span><br><span class="line">var x = a(5);</span><br><span class="line">var y = a(6);</span><br><span class="line"></span><br><span class="line">console.log(x.x)  // undefined</span><br><span class="line">console.log(y.x)  // 6</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： undefined 6</p>
<p><strong>解析：</strong></p>
<ol>
<li>最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x = 5 就相当于：window.x = 5。</strong>之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li>
<li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li>
</ol>
<h3 id="13-代码输出结果-1"><a href="#13-代码输出结果-1" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">    this.a = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(2); </span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2, 3);</span><br><span class="line">console.log(obj2.a); // 3</span><br><span class="line"></span><br><span class="line">var bar = new obj1.foo(4)</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line">console.log(bar.a); // 4</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： 2 3 2 4</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li>
<li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li>
<li>obj1.a会打印出2；</li>
<li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li>
</ol>
<h3 id="14-代码输出结果-1"><a href="#14-代码输出结果-1" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">    this.a = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind(obj1);</span><br><span class="line">bar(2);</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line"></span><br><span class="line">var baz = new bar(3);</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line">console.log(baz.a); // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： 2 2 3</p>
<p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：****new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p>
<h2 id="三、作用域-amp-变量提升-amp-闭包"><a href="#三、作用域-amp-变量提升-amp-闭包" class="headerlink" title="三、作用域&amp;变量提升&amp;闭包"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id="1-代码输出结果-2"><a href="#1-代码输出结果-2" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">   var x = y = 1;</span><br><span class="line">&#125;)();</span><br><span class="line">var z;</span><br><span class="line"></span><br><span class="line">console.log(y); // 1</span><br><span class="line">console.log(z); // undefined</span><br><span class="line">console.log(x); // Uncaught ReferenceError: x is not defined</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p>
<h3 id="2-代码输出结果-2"><a href="#2-代码输出结果-2" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a, b</span><br><span class="line">(function () &#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(b);</span><br><span class="line">   var a = (b = 3);</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(b);   </span><br><span class="line">&#125;)()</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined </span><br><span class="line">undefined </span><br><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">undefined </span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p>
<h3 id="3-代码输出结果-2"><a href="#3-代码输出结果-2" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var friendName = &#x27;World&#x27;;</span><br><span class="line">(function() &#123;</span><br><span class="line">  if (typeof friendName === &#x27;undefined&#x27;) &#123;</span><br><span class="line">    var friendName = &#x27;Jack&#x27;;</span><br><span class="line">    console.log(&#x27;Goodbye &#x27; + friendName);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;Hello &#x27; + friendName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：Goodbye Jack</p>
<p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;World!&#x27;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var name;</span><br><span class="line">    if (typeof name === &#x27;undefined&#x27;) &#123;</span><br><span class="line">        name = &#x27;Jack&#x27;;</span><br><span class="line">        console.log(&#x27;Goodbye &#x27; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;Hello &#x27; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样，答案就一目了然了。</p>
<h3 id="4-代码输出结果-2"><a href="#4-代码输出结果-2" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">  console.log(&#x27;fn1&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var fn2</span><br><span class="line"> </span><br><span class="line">fn1()</span><br><span class="line">fn2()</span><br><span class="line"> </span><br><span class="line">fn2 = function() &#123;</span><br><span class="line">  console.log(&#x27;fn2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fn2()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn1</span><br><span class="line">Uncaught TypeError: fn2 is not a function</span><br><span class="line">fn2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p>
<h3 id="5-代码输出结果-2"><a href="#5-代码输出结果-2" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var temp = 10;</span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(temp); // 10</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    var temp = 10;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(temp); // 报错 Uncaught ReferenceError: temp is not defined</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p>
<h3 id="6-代码输出结果-2"><a href="#6-代码输出结果-2" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a=3;</span><br><span class="line">function c()&#123;</span><br><span class="line">   alert(a);</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line"> var a=4;</span><br><span class="line"> c();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p>
<h3 id="7-代码输出问题-1"><a href="#7-代码输出问题-1" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun(n, o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun: function(m)&#123;</span><br><span class="line">      return fun(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);</span><br><span class="line">var b = fun(0).fun(1).fun(2).fun(3);</span><br><span class="line">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined  0  0  0</span><br><span class="line">undefined  0  1  2</span><br><span class="line">undefined  0  1  1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p>
<h3 id="8-代码输出结果-2"><a href="#8-代码输出结果-2" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = function() &#123;return true;&#125;;   </span><br><span class="line">g = function() &#123;return false;&#125;;   </span><br><span class="line">(function() &#123;   </span><br><span class="line">   if (g() &amp;&amp; [] == ![]) &#123;   </span><br><span class="line">      f = function f() &#123;return false;&#125;;   </span><br><span class="line">      function g() &#123;return true;&#125;  //在匿名函数内部发生函数提升 因此if判断中的g()返回true  </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;)();   </span><br><span class="line">console.log(f());</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果： false</p>
<p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p>
<p>第二个条件是[] == ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p>
<p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p>
<h2 id="四、原型-amp-继承"><a href="#四、原型-amp-继承" class="headerlink" title="四、原型&amp;继承"></a>四、原型&amp;继承</h2><h3 id="1-代码输出结果-3"><a href="#1-代码输出结果-3" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">var p2 = new Person(&#x27;king&#x27;);</span><br><span class="line">console.log(p2.__proto__) //Person.prototype</span><br><span class="line">console.log(p2.__proto__.__proto__) //Object.prototype</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__) // null</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span><br><span class="line">console.log(p2.constructor)//Person</span><br><span class="line">console.log(p2.prototype)//undefined p2是实例，没有prototype属性</span><br><span class="line">console.log(Person.constructor)//Function 一个空函数</span><br><span class="line">console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性</span><br><span class="line">console.log(Person.prototype.constructor)//Person</span><br><span class="line">console.log(Person.prototype.__proto__)// Object.prototype</span><br><span class="line">console.log(Person.__proto__) //Function.prototype</span><br><span class="line">console.log(Function.prototype.__proto__)//Object.prototype</span><br><span class="line">console.log(Function.__proto__)//Function.prototype</span><br><span class="line">console.log(Object.__proto__)//Function.prototype</span><br><span class="line">console.log(Object.prototype.__proto__)//null</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这道义题目考察原型、原型链的基础，记住就可以了。</p>
<h3 id="2-代码输出结果-3"><a href="#2-代码输出结果-3" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a</span><br><span class="line">function Foo () &#123;</span><br><span class="line"> getName = function () &#123;</span><br><span class="line">   console.log(1);</span><br><span class="line"> &#125;</span><br><span class="line"> return this;</span><br><span class="line">&#125;</span><br><span class="line">// b</span><br><span class="line">Foo.getName = function () &#123;</span><br><span class="line"> console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">// c</span><br><span class="line">Foo.prototype.getName = function () &#123;</span><br><span class="line"> console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">// d</span><br><span class="line">var getName = function () &#123;</span><br><span class="line"> console.log(4);</span><br><span class="line">&#125;</span><br><span class="line">// e</span><br><span class="line">function getName () &#123;</span><br><span class="line"> console.log(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();           // 2</span><br><span class="line">getName();               // 4</span><br><span class="line">Foo().getName();         // 1</span><br><span class="line">getName();               // 1 </span><br><span class="line">new Foo.getName();       // 2</span><br><span class="line">new Foo().getName();     // 3</span><br><span class="line">new new Foo().getName(); // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：2 4 1 1 2 3 3</p>
<p><strong>解析：</strong></p>
<ol>
<li>**Foo.getName()**，Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li>
<li>**getName()**，这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li>
<li>**Foo().getName()**，这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li>
<li>**getName()**，上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li>
<li>**new Foo.getName()**，这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li>
<li>**new Foo().getName()**，这里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.protot === Foo.prototype，所以输出 3；</li>
<li>**new new Foo().getName()**，这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li>
</ol>
<h3 id="3-代码输出结果-3"><a href="#3-代码输出结果-3" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var F = function() &#123;&#125;;</span><br><span class="line">Object.prototype.a = function() &#123;</span><br><span class="line">  console.log(&#x27;a&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.b = function() &#123;</span><br><span class="line">  console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var f = new F();</span><br><span class="line">f.a();</span><br><span class="line">f.b();</span><br><span class="line">F.a();</span><br><span class="line">F.b()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">Uncaught TypeError: f.b is not a function</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>解析：</strong></p>
<ol>
<li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。</li>
<li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof Object === true，F instanceof Function === true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li>
</ol>
<h3 id="4-代码输出结果-3"><a href="#4-代码输出结果-3" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    Foo.a = function()&#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;</span><br><span class="line">    this.a = function()&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.a = function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.a = function()&#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.a();</span><br><span class="line">let obj = new Foo();</span><br><span class="line">obj.a();</span><br><span class="line">Foo.a();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：4 2 1</p>
<p><strong>解析：</strong></p>
<ol>
<li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li>
<li>let obj = new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li>
<li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li>
<li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li>
</ol>
<h3 id="5-代码输出结果-3"><a href="#5-代码输出结果-3" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Dog() &#123;</span><br><span class="line">  this.name = &#x27;puppy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;woof!woof!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const dog = new Dog()</span><br><span class="line">console.log(Dog.prototype.constructor === Dog &amp;&amp; dog.constructor === Dog &amp;&amp; dog instanceof Dog)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：true</p>
<p><strong>解析：</strong></p>
<p>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p>
<p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p>
<h3 id="6-代码输出结果-3"><a href="#6-代码输出结果-3" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var A = &#123;n: 4399&#125;;</span><br><span class="line">var B =  function()&#123;this.n = 9999&#125;;</span><br><span class="line">var C =  function()&#123;var n = 8888&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line">C.prototype = A;</span><br><span class="line">var b = new B();</span><br><span class="line">var c = new C();</span><br><span class="line">A.n++</span><br><span class="line">console.log(b.n);</span><br><span class="line">console.log(c.n);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：9999 4400</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new B()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li>
<li>console.log(c.n)，同理，当执行var c = new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li>
</ol>
<h3 id="7-代码输出问题-2"><a href="#7-代码输出问题-2" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">&#125;</span><br><span class="line">function B(a)&#123;</span><br><span class="line">　　this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">function C(a)&#123;</span><br><span class="line">　　if(a)&#123;</span><br><span class="line">this.a = a;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a = 1;</span><br><span class="line">B.prototype.a = 1;</span><br><span class="line">C.prototype.a = 1;</span><br><span class="line"> </span><br><span class="line">console.log(new A().a);</span><br><span class="line">console.log(new B().a);</span><br><span class="line">console.log(new C(2).a);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：1 undefined 2</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li>
<li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li>
<li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。</li>
</ol>
<h3 id="8-代码输出问题"><a href="#8-代码输出问题" class="headerlink" title="8. 代码输出问题"></a>8. 代码输出问题</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">    this.b = [1, 2, this.a];</span><br><span class="line">    this.c = &#123; demo: 5 &#125;;</span><br><span class="line">    this.show = function () &#123;</span><br><span class="line">        console.log(this.a , this.b , this.c.demo );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    this.a = 2;</span><br><span class="line">    this.change = function () &#123;</span><br><span class="line">        this.b.push(this.a);</span><br><span class="line">        this.a = this.b.length;</span><br><span class="line">        this.c.demo = this.a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var parent = new Parent();</span><br><span class="line">var child1 = new Child();</span><br><span class="line">var child2 = new Child();</span><br><span class="line">child1.a = 11;</span><br><span class="line">child2.a = 12;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent.show(); // 1  [1,2,1] 5</span><br><span class="line"></span><br><span class="line">child1.show(); // 11 [1,2,1] 5</span><br><span class="line">child2.show(); // 12 [1,2,1] 5</span><br><span class="line"></span><br><span class="line">parent.show(); // 1 [1,2,1] 5</span><br><span class="line"></span><br><span class="line">child1.show(); // 5 [1,2,1,11,12] 5</span><br><span class="line"></span><br><span class="line">child2.show(); // 6 [1,2,1,11,12] 5</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这道题目值得审题，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p>
<p><strong>解析</strong>：</p>
<ol>
<li>parent.show()，可以直接获得所需的值，没啥好说的；</li>
<li>child1.show()，<code>Child</code>的构造函数原本是指向 <code>Child</code>的，题目显式将 <code>Child</code>类的原型对象指向了 <code>Parent</code>类的一个实例，需要注意 <code>Child.prototype</code>指向的是 <code>Parent</code>的实例 <code>parent</code>，而不是指向 <code>Parent</code>这个类。</li>
<li>child2.show()，这个也没啥好说的；</li>
<li>parent.show()，<code>parent</code>是一个 <code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是 <code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响 <code>parent</code>实例，所以输出结果不变；</li>
<li>child1.show()，<code>child1</code>执行了 <code>change()</code>方法后，发生了怎样的变化呢?</li>
<li><ul>
<li>this.b.push(this.a)，由于this的动态指向特性，this.b会指向 <code>Child.prototype</code>上的b数组,this.a会指向 <code>child1</code>的a属性,所以 <code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li>
<li>this.a = this.b.length，这条语句中 <code>this.a</code>和 <code>this.b</code>的指向与上一句一致，故结果为 <code>child1.a</code>变为4;</li>
<li>this.c.demo = this.a++，由于 <code>child1</code>自身属性并没有c这个属性，所以此处的 <code>this.c</code>会指向 <code>Child.prototype.c</code>，<code>this.a</code>值为4，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为4，而 <code>this.a</code>随后自增为5(4 + 1 = 5)。</li>
</ul>
</li>
<li><code>child2</code>执行了 <code>change()</code>方法, 而 <code>child2</code>和 <code>child1</code>均是 <code>Child</code>类的实例，所以他们的原型链指向同一个原型对象 <code>Child.prototype</code>,也就是同一个 <code>parent</code>实例，所以 <code>child2.change()</code>中所有影响到原型对象的语句都会影响 <code>child1</code>的最终输出结果。</li>
<li><ul>
<li>this.b.push(this.a)，由于this的动态指向特性，this.b会指向 <code>Child.prototype</code>上的b数组,this.a会指向 <code>child2</code>的a属性,所以 <code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li>
<li>this.a = this.b.length，这条语句中 <code>this.a</code>和 <code>this.b</code>的指向与上一句一致，故结果为 <code>child2.a</code>变为5;</li>
<li>this.c.demo = this.a++，由于 <code>child2</code>自身属性并没有c这个属性，所以此处的 <code>this.c</code>会指向 <code>Child.prototype.c</code>，故执行结果为 <code>Child.prototype.c.demo</code>的值变为 <code>child2.a</code>的值5，而 <code>child2.a</code>最终自增为6(5 + 1 = 6)。</li>
</ul>
</li>
</ol>
<h3 id="9-代码输出结果-2"><a href="#9-代码输出结果-2" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function ()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.getSuperValue());</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出结果：true</p>
<p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/sc/sc1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h1 id="手写代码面试题"><a href="#手写代码面试题" class="headerlink" title="手写代码面试题"></a>手写代码面试题</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bingjs.com:8008/img/sx/sx1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>实现步骤：</p>
<ol>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ol>
<p>具体实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let proto = Object.getPrototypeOf(left), // 获取对象的原型</span><br><span class="line">      prototype = right.prototype; // 获取构造函数的 prototype 对象</span><br><span class="line"></span><br><span class="line">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!proto) return false;</span><br><span class="line">    if (proto === prototype) return true;</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null;</span><br><span class="line">  let constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断参数是否是一个函数</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const RESOLVED = &quot;resolved&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  // 保存初始化状态</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // 初始化状态</span><br><span class="line">  this.state = PENDING;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value = null;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved =</span><br><span class="line">    typeof onResolved === &quot;function&quot;</span><br><span class="line">      ? onResolved</span><br><span class="line">      : function(value) &#123;</span><br><span class="line">          return value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &quot;function&quot;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : function(error) &#123;</span><br><span class="line">          throw error;</span><br><span class="line">        &#125;;</span><br><span class="line">    return new MyPromise((resolve,reject)=&gt; &#123;</span><br><span class="line">      // 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">      if (this.state === PENDING) &#123;</span><br><span class="line">        this.resolvedCallbacks.push(onResolved);</span><br><span class="line">        this.rejectedCallbacks.push(onRejected);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line"></span><br><span class="line">      if (this.state === RESOLVED) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          let res = onResolved(this.val)</span><br><span class="line">          if(res instanceof MyPromsie)&#123;</span><br><span class="line">            res.then(v =&gt; &#123;</span><br><span class="line">              resolve(v)</span><br><span class="line">            &#125;,error =&gt; &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;catch(error)&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (this.state === REJECTED) &#123;</span><br><span class="line">        onRejected(this.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-手写-Promise-then"><a href="#5-手写-Promise-then" class="headerlink" title="5. 手写 Promise.then"></a>5. 手写 Promise.then</h3><p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> / <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。</p>
<p><strong>那么，怎么保证后一个</strong> <code>then</code> <strong>里的方法在前一个</strong> <code>then</code><strong>（可能是异步）结束之后再执行呢？</strong></p>
<p>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p>
<ul>
<li>承前：当前一个 <code>promise </code>完成后，调用其 <code>resolve </code>变更状态，在这个 <code>resolve </code>里会依次调用 <code>callbacks </code>里的回调，这样就执行了 <code>then </code>里的方法了</li>
<li>启后：上一步中，当 <code>then </code>里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise </code>的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise </code>的 <code>callbacks </code>数组里的方法，循环往复。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise </code>的 <code>resolve</code>，所以可以在其结果的 <code>then </code>里调用新 <code>promise </code>的 <code>resolve</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onReject)&#123;</span><br><span class="line">    // 保存前一个promise的this</span><br><span class="line">    const self = this; </span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 封装前一个promise成功时执行的函数</span><br><span class="line">      let fulfilled = () =&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          const result = onFulfilled(self.value); // 承前</span><br><span class="line">          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后</span><br><span class="line">        &#125;catch(err)&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 封装前一个promise失败时执行的函数</span><br><span class="line">      let rejected = () =&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          const result = onReject(self.reason);</span><br><span class="line">          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);</span><br><span class="line">        &#125;catch(err)&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      switch(self.status)&#123;</span><br><span class="line">        case PENDING: </span><br><span class="line">          self.onFulfilledCallbacks.push(fulfilled);</span><br><span class="line">          self.onRejectedCallbacks.push(rejected);</span><br><span class="line">          break;</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilled();</span><br><span class="line">          break;</span><br><span class="line">        case REJECT:</span><br><span class="line">          rejected();</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<ul>
<li>连续多个 <code>then </code>里的回调方法是同步注册的，但注册到了不同的 <code>callbacks </code>数组中，因为每次 <code>then </code>都返回新的 <code>promise </code>实例（参考上面的例子和图）</li>
<li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks </code>数组中提前注册的回调</li>
</ul>
<h3 id="6-手写-Promise-all"><a href="#6-手写-Promise-all" class="headerlink" title="6. 手写 Promise.all"></a>6. 手写 Promise.all</h3><p><strong>1) 核心思路</strong></p>
<ol>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li>
<li>这个方法返回一个新的 promise 对象，</li>
<li>遍历传入的参数，用Promise.resolve()将参数”包一层”，使其变成一个promise对象</li>
<li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li>
<li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li>
</ol>
<p><strong>2）实现代码</strong></p>
<p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function promiseAll(promises) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if(!Array.isArray(promises))&#123;</span><br><span class="line">        throw new TypeError(`argument must be a array`)</span><br><span class="line">    &#125;</span><br><span class="line">    var resolvedCounter = 0;</span><br><span class="line">    var promiseNum = promises.length;</span><br><span class="line">    var resolvedResult = [];</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      Promise.resolve(promises[i]).then(value=&gt;&#123;</span><br><span class="line">        resolvedCounter++;</span><br><span class="line">        resolvedResult[i] = value;</span><br><span class="line">        if (resolvedCounter == promiseNum) &#123;</span><br><span class="line">            return resolve(resolvedResult)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,error=&gt;&#123;</span><br><span class="line">        return reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">let p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(3)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">promiseAll([p3, p1, p2]).then(res =&gt; &#123;</span><br><span class="line">    console.log(res) // [3, 1, 2]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="7-手写-Promise-race"><a href="#7-手写-Promise-race" class="headerlink" title="7. 手写 Promise.race"></a>7. 手写 Promise.race</h3><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.race = function (args) &#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    for(let i = 0; i &lt; args.length; i++)&#123;</span><br><span class="line">      Promise.resolve(args[i]).then(resolve,reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-手写防抖函数"><a href="#8-手写防抖函数" class="headerlink" title="8. 手写防抖函数"></a>8. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let context = this,</span><br><span class="line">        args = arguments;</span><br><span class="line"></span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-手写节流函数"><a href="#9-手写节流函数" class="headerlink" title="9. 手写节流函数"></a>9. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  let curTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let context = this,</span><br><span class="line">        args = arguments,</span><br><span class="line">        nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - curTime &gt;= delay) &#123;</span><br><span class="line">      curTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function throttle(fn,wait)&#123;</span><br><span class="line">  let timer = null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let context = this, args = arguments</span><br><span class="line">    if(!timer)&#123;</span><br><span class="line">      timer = setTimeOut(()=&gt;&#123;</span><br><span class="line">        fn.apply(context,args)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="10-手写类型判断函数"><a href="#10-手写类型判断函数" class="headerlink" title="10. 手写类型判断函数"></a>10. 手写类型判断函数</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getType(value) &#123;</span><br><span class="line">  // 判断数据是 null 的情况</span><br><span class="line">  if (value === null) &#123;</span><br><span class="line">    return value + &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断数据是引用类型的情况</span><br><span class="line">  if (typeof value === &quot;object&quot;) &#123;</span><br><span class="line">    let valueClass = Object.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br><span class="line">    type.pop();</span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 判断数据是基本数据类型的情况和函数的情况</span><br><span class="line">    return typeof value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="11-手写-call-函数"><a href="#11-手写-call-函数" class="headerlink" title="11. 手写 call 函数"></a>11. 手写 call 函数</h3><p>call 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// call函数实现</span><br><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  let args = [...arguments].slice(1),</span><br><span class="line">      result = null;</span><br><span class="line">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用函数</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="12-手写-apply-函数"><a href="#12-手写-apply-函数" class="headerlink" title="12. 手写 apply 函数"></a>12. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// apply 函数实现</span><br><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用方法</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="13-手写-bind-函数"><a href="#13-手写-bind-函数" class="headerlink" title="13. 手写 bind 函数"></a>13. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bind 函数实现</span><br><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">      fn = this;</span><br><span class="line">  var bound = function() &#123;</span><br><span class="line">    // 根据调用方式，传入不同绑定值</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  f = Function() &#123;&#125;</span><br><span class="line">  f.prototype = fn.prototype</span><br><span class="line">  bound.prototype = new f();</span><br><span class="line">  return bound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="14-函数柯里化的实现"><a href="#14-函数柯里化的实现" class="headerlink" title="14. 函数柯里化的实现"></a>14. 函数柯里化的实现</h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line"></span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">      // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es6 实现</span><br><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="15-实现AJAX请求"><a href="#15-实现AJAX请求" class="headerlink" title="15. 实现AJAX请求"></a>15. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象</strong>。</li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后<strong>调用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="16-使用Promise封装AJAX请求"><a href="#16-使用Promise封装AJAX请求" class="headerlink" title="16. 使用Promise封装AJAX请求"></a>16. 使用Promise封装AJAX请求</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="17-实现浅拷贝"><a href="#17-实现浅拷贝" class="headerlink" title="17. 实现浅拷贝"></a>17. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p>
<h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
<li>因为 <code>null </code>和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为 <code>null</code>或 <code>undefined</code>，会报错。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let target = &#123;a: 1&#125;;</span><br><span class="line">let object2 = &#123;b: 2&#125;;</span><br><span class="line">let object3 = &#123;c: 3&#125;;</span><br><span class="line">Object.assign(target,object2,object3);  </span><br><span class="line">console.log(target);  // &#123;a: 1, b: 2, c: 3&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line">let obj2 = &#123;...obj1&#125;;</span><br><span class="line">obj1.a = 2;</span><br><span class="line">console.log(obj1); //&#123;a:2,b:&#123;c:1&#125;&#125;</span><br><span class="line">console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line">obj1.b.c = 2;</span><br><span class="line">console.log(obj1); //&#123;a:2,b:&#123;c:2&#125;&#125;</span><br><span class="line">console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><p><strong>1）Array.prototype.slice</strong></p>
<ul>
<li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.slice()); // [1,2,3,4]</span><br><span class="line">console.log(arr.slice() === arr); //false</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>2）Array.prototype.concat</strong></p>
<ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.concat()); // [1,2,3,4]</span><br><span class="line">console.log(arr.concat() === arr); //false</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 浅拷贝的实现;</span><br><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(object).forEach(key =&gt; &#123;</span><br><span class="line">    if(object.hasOwnProperty(key))&#123;</span><br><span class="line">      newObject[key] = object[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;// 浅拷贝的实现;</span><br><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">      //newObject[key] = typeof object[key] === &#x27;object&#x27; ? deepCopy(object[key]) : object[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;// 浅拷贝的实现;</span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="18-实现深拷贝"><a href="#18-实现深拷贝" class="headerlink" title="18. 实现深拷贝"></a>18. 实现深拷贝</h3><ul>
<li><strong>浅拷贝</strong>：浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</li>
<li><strong>深拷贝</strong>：深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li>
</ul>
<h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用 <code>JSON.stringify</code> 将 <code>js</code>对象序列化（JSON字符串），再使用 <code>JSON.parse</code>来反序列化(还原)js对象。</li>
<li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过 <code>JSON.stringify()</code>进行处理之后，都会消失。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;  a: 0,</span><br><span class="line">              b: &#123;</span><br><span class="line">                 c: 0</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 1;</span><br><span class="line">obj1.b.c = 1;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 深拷贝的实现</span><br><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        typeof object[key] === &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Object.keys(object).forEach(key =&gt; &#123;</span><br><span class="line">    if(object.hasOwnProperty(key))&#123;</span><br><span class="line">      newObject[key] = typeof object[key] === &#x27;object&#x27; ? deepCopy(object[key]) : object[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dateFormat(new Date(&#x27;2020-12-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/12/01</span><br><span class="line">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/04/01</span><br><span class="line">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy年MM月dd日&#x27;) // 2020年04月01日</span><br><span class="line">const dateFormat = (dateInput, format)=&gt;&#123;</span><br><span class="line">    var day = dateInput.getDate() </span><br><span class="line">    var month = dateInput.getMonth() + 1  </span><br><span class="line">    var year = dateInput.getFullYear()   </span><br><span class="line">    format = format.replace(/yyyy/, year)</span><br><span class="line">    format = format.replace(/MM/,month)</span><br><span class="line">    format = format.replace(/dd/,day)</span><br><span class="line">    return format</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p>
<ul>
<li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li>
<li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li>
<li>按照上面的规律执行，直到遍历完成</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;</span><br><span class="line">  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>还有一方法就是倒序遍历：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">let length = arr.length,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp;</span><br><span class="line">  while (length) &#123;</span><br><span class="line">    randomIndex = Math.floor(Math.random() * length--);</span><br><span class="line">    temp = arr[length];</span><br><span class="line">    arr[length] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul>
<li>arr=[1,2,3,4,5,6,7,8,9,10]，求和</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr=[1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">let sum = arr.reduce( (total,i) =&gt; total += i,0);</span><br><span class="line">console.log(sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>arr=[1,2,3,[[4,5],6],7,8,9]，求和</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var = arr=[1,2,3,[[4,5],6],7,8,9]</span><br><span class="line">let arr= arr.toString().split(&#x27;,&#x27;).reduce( (total,i) =&gt; total += Number(i),0);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>递归实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5, 6] </span><br><span class="line"></span><br><span class="line">function add(arr) &#123;</span><br><span class="line">    if (arr.length == 1) return arr[0] </span><br><span class="line">    return arr[0] + add(arr.slice(1)) </span><br><span class="line">&#125;</span><br><span class="line">console.log(add(arr)) // 21</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p>
<p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr);  //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>（2）reduce 函数迭代</strong></p>
<p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>（3）扩展运算符实现</strong></p>
<p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>（4）split 和 toString</strong></p>
<p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p>
<p><strong>（5）ES6 中的 flat</strong></p>
<p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p>
<p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。</p>
<p><strong>（6）正则和 JSON 方法</strong></p>
<p>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p>
<p>ES6方法（使用数据结构集合）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>ES5方法：使用map存储不重复的数字</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">uniqueArray(array); // [1, 2, 3, 5, 9, 8]</span><br><span class="line"></span><br><span class="line">function uniqueArray(array) &#123;</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  let res = [];</span><br><span class="line">  for(var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if(!map.hasOwnProperty([array[i]])) &#123;</span><br><span class="line">      map[array[i]] = 1;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _flat(arr, depth) &#123;</span><br><span class="line">  if(!Array.isArray(arr) || depth &lt;= 0) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(cur)) &#123;</span><br><span class="line">      return prev.concat(_flat(cur, depth - 1))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return prev.concat(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">Array.prototype.push = function() &#123;</span><br><span class="line">    for( let i = 0 ; i &lt; arguments.length ; i++)&#123;</span><br><span class="line">        this[this.length] = arguments[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype._filter = function(fn) &#123;</span><br><span class="line">    if (typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const res = [];</span><br><span class="line">    for (let i = 0, len = this.length; i &lt; len; i++) &#123;</span><br><span class="line">        fn(this[i]) &amp;&amp; res.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype._map = function(fn) &#123;</span><br><span class="line">   if (typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const res = [];</span><br><span class="line">    for (let i = 0, len = this.length; i &lt; len; i++) &#123;</span><br><span class="line">        res.push(fn(this[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function repeat(s, n) &#123;</span><br><span class="line">    return (new Array(n + 1)).join(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>递归：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function repeat(s, n) &#123;</span><br><span class="line">    return (n &gt; 0) ? s.concat(repeat(s, --n)) : &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.prototype._reverse = function(a)&#123;</span><br><span class="line">    return a.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new String();</span><br><span class="line">var res = obj._reverse (&#x27;hello&#x27;);</span><br><span class="line">console.log(res);    // olleh</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p>
<h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let format = n =&gt; &#123;</span><br><span class="line">    let num = n.toString() // 转成字符串</span><br><span class="line">    let decimals = &#x27;&#x27;</span><br><span class="line">        // 判断是否有小数</span><br><span class="line">    num.indexOf(&#x27;.&#x27;) &gt; -1 ? decimals = num.split(&#x27;.&#x27;)[1] : decimals</span><br><span class="line">    let len = num.length</span><br><span class="line">    if (len &lt;= 3) &#123;</span><br><span class="line">        return num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let temp = &#x27;&#x27;</span><br><span class="line">        let remainder = len % 3</span><br><span class="line">        decimals ? temp = &#x27;.&#x27; + decimals : temp</span><br><span class="line">        if (remainder &gt; 0) &#123; // 不是3的整数倍</span><br><span class="line">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp</span><br><span class="line">        &#125; else &#123; // 是3的整数倍</span><br><span class="line">            return num.slice(0, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">format(12323.33)  // &#x27;12,323.33&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>数字无小数版本：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let format = n =&gt; &#123;</span><br><span class="line">    let num = n.toString() </span><br><span class="line">    let len = num.length</span><br><span class="line">    if (len &lt;= 3) &#123;</span><br><span class="line">        return num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let remainder = len % 3</span><br><span class="line">        if (remainder &gt; 0) &#123; // 不是3的整数倍</span><br><span class="line">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) </span><br><span class="line">        &#125; else &#123; // 是3的整数倍</span><br><span class="line">            return num.slice(0, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">format(1232323)  // &#x27;1,232,323&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.MAX_VALUE // 1.7976931348623157e+308</span><br><span class="line">Number.MAX_SAFE_INTEGER // 9007199254740991</span><br><span class="line">Number.MIN_VALUE // 5e-324</span><br><span class="line">Number.MIN_SAFE_INTEGER // -9007199254740991</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p>
<p>实现一个算法进行大数的相加：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sumBigNumber(a, b) &#123;</span><br><span class="line">  let res = &#x27;&#x27;;</span><br><span class="line">  let temp = 0;</span><br><span class="line">  </span><br><span class="line">  a = a.split(&#x27;&#x27;);</span><br><span class="line">  b = b.split(&#x27;&#x27;);</span><br><span class="line">  </span><br><span class="line">  while (a.length || b.length || temp) &#123;</span><br><span class="line">    temp += ~~a.pop() + ~~b.pop();</span><br><span class="line">    res = (temp % 10) + res;</span><br><span class="line">    temp  = temp &gt; 9</span><br><span class="line">  &#125;</span><br><span class="line">  return res.replace(/^0+/, &#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>其主要的思路如下：</p>
<ul>
<li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li>
<li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li>
<li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li>
<li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li>
<li>重复上述操作，直至计算结束</li>
</ul>
<h3 id="15-实现-add-1-2-3"><a href="#15-实现-add-1-2-3" class="headerlink" title="15. 实现 add(1)(2)(3)"></a>15. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>1）粗暴版</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add (a) &#123;</span><br><span class="line">return function (b) &#123;</span><br><span class="line">    return function (c) &#123;</span><br><span class="line">      return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1)(2)(3)); // 6</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2）柯里化解决方案</p>
<ul>
<li>参数长度固定</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var add = function (m) &#123;</span><br><span class="line">  var temp = function (n) &#123;</span><br><span class="line">    return add(m + n);</span><br><span class="line">  &#125;</span><br><span class="line">  temp.toString = function () &#123;</span><br><span class="line">    return m;</span><br><span class="line">  &#125;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(add(3)(4)(5)); // 12</span><br><span class="line">console.log(add(3)(6)(9)(25)); // 43</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于add(3)(4)(5)，其执行过程如下：</p>
<ol>
<li>先执行add(3)，此时m=3，并且返回temp函数；</li>
<li>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数</li>
<li>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数</li>
<li>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。</li>
</ol>
<ul>
<li>参数长度不固定</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add (...args) &#123;</span><br><span class="line">    //求和</span><br><span class="line">    return args.reduce((a, b) =&gt; a + b)</span><br><span class="line">&#125;</span><br><span class="line">function currying (fn) &#123;</span><br><span class="line">    let args = []</span><br><span class="line">    return function temp (...newArgs) &#123;</span><br><span class="line">        if (newArgs.length) &#123;</span><br><span class="line">            args = [</span><br><span class="line">                ...args,</span><br><span class="line">                ...newArgs</span><br><span class="line">            ]</span><br><span class="line">            return temp</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let val = fn.apply(this, args)</span><br><span class="line">            args = [] //保证再次调用时清空</span><br><span class="line">            return val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let addCurry = currying(add)</span><br><span class="line">console.log(addCurry(1)(2)(3)(4, 5)())  //15</span><br><span class="line">console.log(addCurry(1)(2)(3, 4, 5)())  //15</span><br><span class="line">console.log(addCurry(1)(2, 3, 4, 5)())  //15</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="16-实现类数组转化为数组"><a href="#16-实现类数组转化为数组" class="headerlink" title="16. 实现类数组转化为数组"></a>16. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="17-使用-reduce-求和"><a href="#17-使用-reduce-求和" class="headerlink" title="17. 使用 reduce 求和"></a>17. 使用 reduce 求和</h3><p>arr = [1,2,3,4,5,6,7,8,9,10]，求和</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">arr.reduce((prev, cur) =&gt; &#123; return prev + cur &#125;, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>arr = [1,2,3,[[4,5],6],7,8,9]，求和</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">arr.flat(Infinity).reduce((prev, cur) =&gt; &#123; return prev + cur &#125;, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>arr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&#123;a:9, b:3, c:4&#125;, &#123;a:1, b:3&#125;, &#123;a:3&#125;] </span><br><span class="line"></span><br><span class="line">arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">    return prev + cur[&quot;a&quot;];</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="18-将js对象转化为树形结构"><a href="#18-将js对象转化为树形结构" class="headerlink" title="18. 将js对象转化为树形结构"></a>18. 将js对象转化为树形结构</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 转换前：</span><br><span class="line">source = [&#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            pid: 0,</span><br><span class="line">            name: &#x27;body&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 3,</span><br><span class="line">            pid: 2,</span><br><span class="line">            name: &#x27;div&#x27;</span><br><span class="line">          &#125;]</span><br><span class="line">// 转换为: </span><br><span class="line">tree = [&#123;</span><br><span class="line">          id: 1,</span><br><span class="line">          pid: 0,</span><br><span class="line">          name: &#x27;body&#x27;,</span><br><span class="line">          children: [&#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;,</span><br><span class="line">            children: [&#123;</span><br><span class="line">              id: 3,</span><br><span class="line">              pid: 1,</span><br><span class="line">              name: &#x27;div&#x27;</span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function jsonToTree(data) &#123;</span><br><span class="line">  // 初始化结果数组，并判断输入数据的格式</span><br><span class="line">  let result = []</span><br><span class="line">  if(!Array.isArray(data)) &#123;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用map，将当前对象的id与当前对象对应存储起来</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    map[item.id] = item;</span><br><span class="line">  &#125;);</span><br><span class="line">  // </span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    let parent = map[item.pid];</span><br><span class="line">    if(parent) &#123;</span><br><span class="line">      (parent.children || (parent.children = [])).push(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="19-使用ES5和ES6求函数参数的和"><a href="#19-使用ES5和ES6求函数参数的和" class="headerlink" title="19. 使用ES5和ES6求函数参数的和"></a>19. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    Array.prototype.forEach.call(arguments, function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>ES6：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum(...nums) &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    nums.forEach(function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="20-解析-URL-Params-为对象"><a href="#20-解析-URL-Params-为对象" class="headerlink" title="20. 解析 URL Params 为对象"></a>20. 解析 URL Params 为对象</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let url = &#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;;</span><br><span class="line">parseParam(url)</span><br><span class="line">/* 结果</span><br><span class="line">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="line">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="line">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="line">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parseParam(url) &#123;</span><br><span class="line">  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br><span class="line">  const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中</span><br><span class="line">  let paramsObj = &#123;&#125;;</span><br><span class="line">  // 将 params 存到对象中</span><br><span class="line">  paramsArr.forEach(param =&gt; &#123;</span><br><span class="line">    if (/=/.test(param)) &#123; // 处理有 value 的参数</span><br><span class="line">      let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value</span><br><span class="line">      val = decodeURIComponent(val); // 解码</span><br><span class="line">      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br><span class="line">      if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值</span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">      &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值</span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123; // 处理没有 value 的参数</span><br><span class="line">      paramsObj[param] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return paramsObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p>
<p>三个亮灯函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function red() &#123;</span><br><span class="line">    console.log(&#x27;red&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function green() &#123;</span><br><span class="line">    console.log(&#x27;green&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function yellow() &#123;</span><br><span class="line">    console.log(&#x27;yellow&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p>
<h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const task = (timer, light, callback) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        if (light === &#x27;red&#x27;) &#123;</span><br><span class="line">            red()</span><br><span class="line">        &#125;</span><br><span class="line">        else if (light === &#x27;green&#x27;) &#123;</span><br><span class="line">            green()</span><br><span class="line">        &#125;</span><br><span class="line">        else if (light === &#x27;yellow&#x27;) &#123;</span><br><span class="line">            yellow()</span><br><span class="line">        &#125;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">&#125;</span><br><span class="line">task(3000, &#x27;red&#x27;, () =&gt; &#123;</span><br><span class="line">    task(2000, &#x27;green&#x27;, () =&gt; &#123;</span><br><span class="line">        task(1000, &#x27;yellow&#x27;, Function.prototype)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p>
<p>上面提到过递归，可以递归亮灯的一个周期：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const step = () =&gt; &#123;</span><br><span class="line">    task(3000, &#x27;red&#x27;, () =&gt; &#123;</span><br><span class="line">        task(2000, &#x27;green&#x27;, () =&gt; &#123;</span><br><span class="line">            task(1000, &#x27;yellow&#x27;, step)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p>
<h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const task = (timer, light) =&gt; </span><br><span class="line">    new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            if (light === &#x27;red&#x27;) &#123;</span><br><span class="line">                red()</span><br><span class="line">            &#125;</span><br><span class="line">            else if (light === &#x27;green&#x27;) &#123;</span><br><span class="line">                green()</span><br><span class="line">            &#125;</span><br><span class="line">            else if (light === &#x27;yellow&#x27;) &#123;</span><br><span class="line">                yellow()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line">const step = () =&gt; &#123;</span><br><span class="line">    task(3000, &#x27;red&#x27;)</span><br><span class="line">        .then(() =&gt; task(2000, &#x27;green&#x27;))</span><br><span class="line">        .then(() =&gt; task(2100, &#x27;yellow&#x27;))</span><br><span class="line">        .then(step)</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p>
<h4 id="（3）用-async-await-实现"><a href="#（3）用-async-await-实现" class="headerlink" title="（3）用 async/await 实现"></a>（3）用 async/await 实现</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const taskRunner =  async () =&gt; &#123;</span><br><span class="line">    await task(3000, &#x27;red&#x27;)</span><br><span class="line">    await task(2000, &#x27;green&#x27;)</span><br><span class="line">    await task(2100, &#x27;yellow&#x27;)</span><br><span class="line">    taskRunner()</span><br><span class="line">&#125;</span><br><span class="line">taskRunner()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用闭包实现</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">// 使用 let 块级作用域</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function childNum(num, count)&#123;</span><br><span class="line">    let allplayer = [];  </span><br><span class="line">    for(let i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        allplayer[i] = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    let exitCount = 0;    // 离开人数</span><br><span class="line">    let counter = 0;      // 记录报数</span><br><span class="line">    let curIndex = 0;     // 当前下标</span><br><span class="line">  </span><br><span class="line">    while(exitCount &lt; num - 1)&#123;</span><br><span class="line">        if(allplayer[curIndex] !== 0) counter++;  </span><br><span class="line">      </span><br><span class="line">        if(counter == count)&#123;</span><br><span class="line">            allplayer[curIndex] = 0;               </span><br><span class="line">            counter = 0;</span><br><span class="line">            exitCount++;  </span><br><span class="line">        &#125;</span><br><span class="line">        curIndex++;</span><br><span class="line">        if(curIndex == num)&#123;</span><br><span class="line">            curIndex = 0             </span><br><span class="line">        &#125;;         </span><br><span class="line">    &#125;  </span><br><span class="line">    for(i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        if(allplayer[i] !== 0)&#123;</span><br><span class="line">            return allplayer[i]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">childNum(30, 3)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let imageAsync=(url)=&gt;&#123;</span><br><span class="line">            return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">                let img = new Image();</span><br><span class="line">                img.src = url;</span><br><span class="line">                img.οnlοad=()=&gt;&#123;</span><br><span class="line">                    console.log(`图片请求成功，此处进行通用操作`);</span><br><span class="line">                    resolve(image);</span><br><span class="line">                &#125;</span><br><span class="line">                img.οnerrοr=(err)=&gt;&#123;</span><br><span class="line">                    console.log(`失败，此处进行失败的通用操作`);</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">imageAsync(&quot;url&quot;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;加载成功&quot;);</span><br><span class="line">&#125;).catch((error)=&gt;&#123;</span><br><span class="line">    console.log(&quot;加载失败&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventCenter&#123;</span><br><span class="line">  // 1. 定义事件容器，用来装事件数组</span><br><span class="line">    let handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 2. 添加事件方法，参数：事件名 事件方法</span><br><span class="line">  addEventListener(type, handler) &#123;</span><br><span class="line">    // 创建新数组容器</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      this.handlers[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    // 存入事件</span><br><span class="line">    this.handlers[type].push(handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 3. 触发事件，参数：事件名 事件参数</span><br><span class="line">  dispatchEvent(type, params) &#123;</span><br><span class="line">    // 若没有注册该事件则抛出错误</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      return new Error(&#x27;该事件未注册&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 触发事件</span><br><span class="line">    this.handlers[type].forEach(handler =&gt; &#123;</span><br><span class="line">      handler(...params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span><br><span class="line">  removeEventListener(type, handler) &#123;</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      return new Error(&#x27;事件无效&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!handler) &#123;</span><br><span class="line">      // 移除事件</span><br><span class="line">      delete this.handlers[type]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const index = this.handlers[type].findIndex(el =&gt; el === handler)</span><br><span class="line">      if (index === -1) &#123;</span><br><span class="line">        return new Error(&#x27;无该绑定事件&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      // 移除事件</span><br><span class="line">      this.handlers[type].splice(index, 1)</span><br><span class="line">      if (this.handlers[type].length === 0) &#123;</span><br><span class="line">        delete this.handlers[type]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function findMostWord(article) &#123;</span><br><span class="line">  // 合法性判断</span><br><span class="line">  if (!article) return;</span><br><span class="line">  // 参数处理</span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line">  let wordList = article.match(/[a-z]+/g),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = 0,</span><br><span class="line">    maxWord = &quot;&quot;;</span><br><span class="line">  article = &quot; &quot; + wordList.join(&quot;  &quot;) + &quot; &quot;;</span><br><span class="line">  // 遍历判断单词出现次数</span><br><span class="line">  wordList.forEach(function(item) &#123;</span><br><span class="line">    if (visited.indexOf(item) &lt; 0) &#123;</span><br><span class="line">      // 加入 visited </span><br><span class="line">      visited.push(item);</span><br><span class="line">      let word = new RegExp(&quot; &quot; + item + &quot; &quot;, &quot;g&quot;),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line">      if (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return maxWord + &quot;  &quot; + maxNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">    class HttpRequestUtil &#123;</span><br><span class="line">        async get(url) &#123;</span><br><span class="line">            const res = await fetch(url);</span><br><span class="line">            const data = await res.json();</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">        async post(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;POST&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                body: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        async put(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;PUT&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                data: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        async delete(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;DELETE&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                data: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const httpRequestUtil = new HttpRequestUtil();</span><br><span class="line">    const res = await httpRequestUtil.get(&#x27;http://golderbrother.cn/&#x27;);</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父方法</span><br><span class="line">function SupperFunction(flag1)&#123;</span><br><span class="line">    this.flag1 = flag1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子方法</span><br><span class="line">function SubFunction(flag2)&#123;</span><br><span class="line">    this.flag2 = flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//父实例</span><br><span class="line">var superInstance = new SupperFunction(true);</span><br><span class="line"></span><br><span class="line">//子继承父</span><br><span class="line">SubFunction.prototype = superInstance;</span><br><span class="line"></span><br><span class="line">//子实例</span><br><span class="line">var subInstance = new SubFunction(false);</span><br><span class="line">//子调用自己和父的属性</span><br><span class="line">subInstance.flag1;   // true</span><br><span class="line">subInstance.flag2;   // false</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">let input = document.getElementById(&#x27;input&#x27;)</span><br><span class="line">let span = document.getElementById(&#x27;span&#x27;)</span><br><span class="line">// 数据劫持</span><br><span class="line">Object.defineProperty(obj, &#x27;text&#x27;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#x27;获取数据了&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal) &#123;</span><br><span class="line">    console.log(&#x27;数据更新了&#x27;)</span><br><span class="line">    input.value = newVal</span><br><span class="line">    span.innerHTML = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 输入监听</span><br><span class="line">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class="line">  obj.text = e.target.value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hash路由</span><br><span class="line">class Route&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 路由存储对象</span><br><span class="line">    this.routes = &#123;&#125;</span><br><span class="line">    // 当前hash</span><br><span class="line">    this.currentHash = &#x27;&#x27;</span><br><span class="line">    // 绑定this，避免监听时this指向改变</span><br><span class="line">    this.freshRoute = this.freshRoute.bind(this)</span><br><span class="line">    // 监听</span><br><span class="line">    window.addEventListener(&#x27;load&#x27;, this.freshRoute, false)</span><br><span class="line">    window.addEventListener(&#x27;hashchange&#x27;, this.freshRoute, false)</span><br><span class="line">  &#125;</span><br><span class="line">  // 存储</span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    this.routes[path] = cb || function () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    this.currentHash = location.hash.slice(1) || &#x27;/&#x27;</span><br><span class="line">    this.routes[this.currentHash]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 递归</span><br><span class="line">function fn (n)&#123;</span><br><span class="line">    if(n==0) return 0</span><br><span class="line">    if(n==1) return 1</span><br><span class="line">    return fn(n-2)+fn(n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 优化</span><br><span class="line">function fibonacci2(n) &#123;</span><br><span class="line">    const arr = [1, 1, 2];</span><br><span class="line">    const arrLen = arr.length;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= arrLen) &#123;</span><br><span class="line">        return arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = arrLen; i &lt; n; i++) &#123;</span><br><span class="line">        arr.push(arr[i - 1] + arr[ i - 2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr[arr.length - 1];</span><br><span class="line">&#125;</span><br><span class="line">// 非递归</span><br><span class="line">function fn(n) &#123;</span><br><span class="line">    let pre1 = 1;</span><br><span class="line">    let pre2 = 1;</span><br><span class="line">    let current = 2;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 2; i &lt; n; i++) &#123;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = current;</span><br><span class="line">        current = pre1 + pre2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function (s) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let i = -1</span><br><span class="line">    let res = 0</span><br><span class="line">    let n = s.length</span><br><span class="line">    for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        if (map.has(s[j])) &#123;</span><br><span class="line">            i = Math.max(i, map.get(s[j]))</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, j - i)</span><br><span class="line">        map.set(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
<p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mySetInterval(fn, timeout) &#123;</span><br><span class="line">  // 控制器，控制定时器是否继续执行</span><br><span class="line">  var timer = &#123;</span><br><span class="line">    flag: true</span><br><span class="line">  &#125;;</span><br><span class="line">  // 设置递归函数，模拟定时器执行。</span><br><span class="line">  function interval() &#123;</span><br><span class="line">    if (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      setTimeout(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 启动定时器</span><br><span class="line">  setTimeout(interval, timeout);</span><br><span class="line">  // 返回控制器</span><br><span class="line">  return timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 动态的加载js文件</span><br><span class="line">function addScript(src) &#123;</span><br><span class="line">  const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.type = &quot;text/javascript&quot;;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">addScript(&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;);</span><br><span class="line">// 设置一个全局的callback函数来接收回调结果</span><br><span class="line">function handleRes(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;</span><br><span class="line">// 接口返回的数据格式</span><br><span class="line">handleRes(&#123;a: 1, b: 2&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用 <code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p>
<p>下面方法可以用来判断一个对象中是否已存在循环引用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isCycleObject = (obj,parent) =&gt; &#123;</span><br><span class="line">    const parentArr = parent || [obj];</span><br><span class="line">    for(let i in obj) &#123;</span><br><span class="line">        if(typeof obj[i] === &#x27;object&#x27;) &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            parentArr.forEach((pObj) =&gt; &#123;</span><br><span class="line">                if(pObj === obj[i])&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            if(flag) return true;</span><br><span class="line">            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);</span><br><span class="line">            if(flag) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const a = 1;</span><br><span class="line">const b = &#123;a&#125;;</span><br><span class="line">const c = &#123;b&#125;;</span><br><span class="line">const o = &#123;d:&#123;a:3&#125;,c&#125;</span><br><span class="line">o.c.b.aa = a;</span><br><span class="line"></span><br><span class="line">console.log(isCycleObject(o)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>查找有序二维数组的目标值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var findNumberIn2DArray = function(matrix, target) &#123;</span><br><span class="line">    if (matrix == null || matrix.length == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let row = 0;</span><br><span class="line">    let column = matrix[0].length - 1;</span><br><span class="line">    while (row &lt; matrix.length &amp;&amp; column &gt;= 0) &#123;</span><br><span class="line">        if (matrix[row][column] == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (matrix[row][column] &gt; target) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>二维数组斜向打印：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function printMatrix(arr)&#123;</span><br><span class="line">  let m = arr.length, n = arr[0].length</span><br><span class="line">    let res = []</span><br><span class="line">  </span><br><span class="line">  // 左上角，从0 到 n - 1 列进行打印</span><br><span class="line">  for (let k = 0; k &lt; n; k++) &#123;</span><br><span class="line">    for (let i = 0, j = k; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) &#123;</span><br><span class="line">      res.push(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 右下角，从1 到 n - 1 行进行打印</span><br><span class="line">  for (let k = 1; k &lt; m; k++) &#123;</span><br><span class="line">    for (let i = k, j = n - 1; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) &#123;</span><br><span class="line">      res.push(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
